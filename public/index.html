<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<!-- Favicon -->
	<link rel="icon" type="image/svg+xml" href="/favicon.svg">
	<link rel="alternate icon" type="image/x-icon" href="/favicon.ico">
	<link rel="apple-touch-icon" href="/favicon.svg">
    <title>Planchís</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(15, 1fr);
            grid-template-rows: repeat(15, 1fr);
            background-color: #fff;
            border: 2px solid #000;
            aspect-ratio: 1;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            position: relative;
        }
        
        .cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 12px;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        
        .cell:not(.no-border) {
            border: 1px solid #000;
        }
        
        /* Colores exactos de los cuadrantes */
        .zone-pink { background-color: #ff1493; }
        .zone-blue { background-color: #1aa3ff; }
        .zone-yellow { background-color: #ffde00; }
        .zone-green { background-color: #00b050; }
        
        /* Símbolos grandes en los cuadrantes */
        .house-symbol {
            width: 80%;
            height: 80%;
            border: 3px solid black;
            border-radius: 50%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }
        
        /* Símbolo del Sol - círculos concéntricos con punto central */
        .sun-symbol {
            position: relative;
        }
        
        .sun-symbol::before {
            content: "";
            position: absolute;
            width: 60%;
            height: 60%;
            border: 6px solid black;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .sun-symbol::after {
            content: "";
            position: absolute;
            width: 15%;
            height: 15%;
            background-color: black;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Símbolo de la Luna - luna creciente */
        .moon-symbol {
            position: relative;
            overflow: hidden;
        }
        
        .moon-symbol::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: transparent;
            border: 5px solid black;
            box-sizing: border-box;
        }
        
        .moon-symbol::after {
            content: "";
            position: absolute;
            width: 75%;
            height: 75%;
            background-color: inherit;
            border-radius: 50%;
            top: 12.5%;
            right: -30%;
            box-shadow: 0 0 0 5px black;
        }
        
        /* Casa completa con overlay */
        .house-overlay {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }
        
        /* Estilo para los círculos con símbolos */
        .symbol {
            position: relative;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            font-weight: bold;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            z-index: 2;
        }
        
        /* Colores específicos para los círculos */
        .circle-green { background-color: #00b050; color: white; }
        .circle-blue { background-color: #1aa3ff; color: white; }
        .circle-pink, .circle-red { background-color: #ff1493; color: white; }
        .circle-yellow { background-color: #ffde00; color: black; }
        .circle-white { background-color: white; color: black; border: 1px solid #000; }
        .circle-cyan { background-color: #00ffff; color: black; }
        .circle-darkblue { background-color: #000088; color: white; }
        
        /* Saturno en fondo azul oscuro */
        .saturn-cell {
            background-color: #000088;
        }

        /* Fichas de los jugadores */
        .piece {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #333;
            z-index: 10;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Colores de jugadores que coinciden con los cuadrantes */
        .player1 { background-color: #00b050; } /* Verde */
        .player2 { background-color: #1aa3ff; } /* Azul */
        .player3 { background-color: #ff1493; } /* Rosa */
        .player4 { background-color: #ffde00; } /* Amarillo */
        
        /* Estilos para el dado y controles del juego */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .dice-container {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .dice {
            width: 80px;
            height: 80px;
            background-color: #f5f5f5;
            border: 2px solid #333;
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .dice-result {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 24px;
        }
        
        .element-info {
            margin-left: 10px;
            font-weight: bold;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            flex-wrap: wrap;
        }
        
        .player-info {
            display: flex;
            flex-direction: column;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .player-info.active {
            box-shadow: 0 0 8px 2px rgba(255, 215, 0, 0.6);
        }
        
        .houses {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        
        .house-piece {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #333;
        }
        
        h1, h2, h3 {
            margin: 5px 0;
        }
        
        .message-log {
            height: 150px;
            overflow-y: auto;
            padding: 10px;
            background-color: white;
            border: 1px solid #ddd;
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
            margin: 20px auto 0;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-bottom: 1px solid #eee;
        }
        
        /* Resaltado para movimientos posibles */
        .highlight-move {
            box-shadow: 0 0 10px 3px gold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 10px 3px gold; }
            50% { box-shadow: 0 0 15px 5px gold; }
            100% { box-shadow: 0 0 10px 3px gold; }
        }
        
        /* Destacar las líneas de juego */
        .line-highlight {
            position: relative;
        }
        
        .line-highlight::after {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-sizing: border-box;
            pointer-events: none;
            z-index: 1;
        }
        
        /* Destacar la ficha seleccionada */
        .selected-piece {
            box-shadow: 0 0 10px 3px gold, 0 0 20px 5px red;
            z-index: 20;
            animation: selectedPulse 1.5s infinite;
        }

        @keyframes selectedPulse {
            0% { box-shadow: 0 0 10px 3px gold, 0 0 20px 5px red; }
            50% { box-shadow: 0 0 15px 5px gold, 0 0 25px 7px red; }
            100% { box-shadow: 0 0 10px 3px gold, 0 0 20px 5px red; }
        }
        
        /* Estilo para el diálogo de configuración */
        .config-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .config-container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }
        
        .config-title {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        
        .config-option {
            margin-bottom: 20px;
        }
        
        .config-option h3 {
            margin-bottom: 10px;
        }
        
        .player-config {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .player-toggle {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .player-toggle label {
            margin-left: 8px;
        }
        
        .start-button {
            background-color: #4CAF50;
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            margin-top: 20px;
            width: 100%;
        }
        
        .start-button:hover {
            background-color: #45a049;
        }
        
        .player-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .player-card {
            border: 2px solid #ccc;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
            width: calc(50% - 10px);
            box-sizing: border-box;
        }
        
        .player-card.selected {
            border-color: #4CAF50;
            background-color: rgba(76, 175, 80, 0.1);
        }
        
        .player-card.player1 { border-color: #00b050; }
        .player-card.player2 { border-color: #1aa3ff; }
        .player-card.player3 { border-color: #ff1493; }
        .player-card.player4 { border-color: #ffde00; }
        
        .player-card.player1.selected { background-color: rgba(0, 176, 80, 0.2); }
        .player-card.player2.selected { background-color: rgba(26, 163, 255, 0.2); }
        .player-card.player3.selected { background-color: rgba(255, 20, 147, 0.2); }
        .player-card.player4.selected { background-color: rgba(255, 222, 0, 0.2); }
        
        .game-mode {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
        }
        
        .mode-button {
            padding: 10px 20px;
            background-color: #f5f5f5;
            border: 2px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .mode-button.selected {
            background-color: #4CAF50;
            color: white;
            border-color: #368a39;
        }
        
        /* CSS para el contenedor del SVG */
        .center-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #2a2a8c; /* Azul oscuro */
            overflow: hidden;
        }

        .center-container svg {
            width: 90%;
            height: 90%;
            max-width: 100%;
        }
        
        .selected-house {
            box-shadow: 0 0 10px 3px gold, 0 0 20px 5px red;
            animation: selectedPulse 1.5s infinite;
        }
        
        /* Estilos adicionales para responsividad en móviles */
        .logo-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .game-logo {
            width: 60px;
            height: 60px;
            margin-right: 15px;
        }
        
        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        /* Hacer la interfaz del juego responsiva */
        @media (max-width: 768px) {
            .game-info {
                flex-direction: column;
                align-items: center;
            }
            
            .player-info {
                width: 100%;
                margin-bottom: 10px;
            }
            
            .player-card {
                width: 100%;
            }
            
            .dice-container {
                flex-direction: column;
                align-items: center;
            }
            
            .element-info {
                margin: 10px 0;
                text-align: center;
            }
            
            .controls {
                padding: 15px;
            }
            
            button {
                margin-bottom: 10px;
                width: 100%;
            }
            
            .symbol {
                width: 24px;
                height: 24px;
                font-size: 14px;
            }
            
            .player-card h3 {
                font-size: 14px;
            }
            
            .player-toggle label {
                font-size: 14px;
            }
            
            .mode-button {
                padding: 8px 15px;
                font-size: 14px;
            }
            
            .game-logo {
                width: 40px;
                height: 40px;
            }
            
            h1 {
                font-size: 24px;
            }
        }
        
        @media (max-width: 480px) {
            .cell {
                font-size: 10px;
            }
            
            .symbol {
                width: 18px;
                height: 18px;
                font-size: 12px;
            }
            
            .dice {
                width: 60px;
                height: 60px;
            }
            
            .dice-result {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            .house-piece {
                width: 12px;
                height: 12px;
            }
            
            .piece {
                width: 12px;
                height: 12px;
            }
            
            .config-container {
                padding: 15px;
            }

            .house-symbol::before {
                border-width: 4px;
            }
            
            .house-symbol::after {
                width: 12%;
                height: 12%;
            }
        }

        @media (max-width: 360px) {
            .symbol {
                width: 14px;
                height: 14px;
                font-size: 10px;
            }
            
            .piece {
                width: 10px;
                height: 10px;
                border-width: 1px;
            }
            
            .house-piece {
                width: 10px;
                height: 10px;
                border-width: 1px;
            }
            
            .house-symbol::before {
                border-width: 3px;
            }
            
            .sun-symbol::before {
                border-width: 4px;
            }
            
            .moon-symbol::before {
                border-width: 3px;
            }
            
            .moon-symbol::after {
                box-shadow: 0 0 0 3px black;
            }
        }
        
        @media (max-width: 320px) {
            .cell {
                font-size: 8px;
            }
            
            .symbol {
                width: 12px;
                height: 12px;
                font-size: 8px;
            }
            
            .game-board {
                margin: 0;
                width: 100%;
            }
            
            .dice {
                width: 50px;
                height: 50px;
            }
            
            .dice-result {
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
            
            .piece {
                width: 8px;
                height: 8px;
                border-width: 1px;
            }
            
            .house-piece {
                width: 8px;
                height: 8px;
                border-width: 1px;
            }
        }
    </style>
</head>
<!-- Soporte para juego en red -->
<script src="/socket.io/socket.io.js"></script>
<script>
// Código del cliente para juego en red
let socket;
let networkGameId = null;
let myPlayerIndex = -1;
let isNetworkGame = false;

// Elementos para el menú de red
const networkMenuHTML = `
<div id="network-menu" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 200; display: flex; justify-content: center; align-items: center;">
    <div style="background: white; padding: 20px; border-radius: 10px; max-width: 500px; width: 90%;">
        <h2 style="text-align: center;">Planchís en Red Local</h2>
        
        <div id="network-modes" style="display: flex; justify-content: center; margin: 20px 0;">
            <button id="offline-mode" style="margin: 0 10px; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Modo Local</button>
            <button id="online-mode" style="margin: 0 10px; padding: 10px; background: #2196F3; color: white; border: none; border-radius: 5px; cursor: pointer;">Modo Red</button>
        </div>
        
        <div id="network-create-join" style="display: none;">
            <div style="display: flex; justify-content: center; margin: 20px 0;">
                <button id="create-game" style="margin: 0 10px; padding: 10px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Crear Partida</button>
                <button id="join-game" style="margin: 0 10px; padding: 10px; background: #FFC107; color: black; border: none; border-radius: 5px; cursor: pointer;">Unirse a Partida</button>
            </div>
            
            <div id="create-game-options" style="display: none; margin-top: 20px;">
                <h3 style="text-align: center;">Crear Nueva Partida</h3>
                <div style="display: flex; justify-content: center; margin: 10px 0;">
                    <button data-players="2" class="game-mode-btn" style="margin: 0 10px; padding: 10px; background: #e0e0e0; border: 2px solid #ccc; border-radius: 5px; cursor: pointer;">2 Jugadores</button>
                    <button data-players="4" class="game-mode-btn" style="margin: 0 10px; padding: 10px; background: #e0e0e0; border: 2px solid #ccc; border-radius: 5px; cursor: pointer;">4 Jugadores</button>
                </div>
                <div style="text-align: center; margin-top: 20px;">
                    <button id="start-network-game" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; display: none;">Crear Partida</button>
                </div>
            </div>
            
            <div id="join-game-options" style="display: none; margin-top: 20px;">
                <h3 style="text-align: center;">Unirse a Partida</h3>
                <div style="display: flex; justify-content: center; margin: 10px 0;">
                    <input type="text" id="game-code-input" placeholder="Introduce código de partida" style="padding: 10px; width: 200px; margin-right: 10px;">
                    <button id="join-game-btn" style="padding: 10px; background: #FFC107; color: black; border: none; border-radius: 5px; cursor: pointer;">Unirse</button>
                </div>
                <div id="available-games" style="margin-top: 20px; max-height: 200px; overflow-y: auto;">
                </div>
            </div>
        </div>
    </div>
</div>`;

// Mostrar menú de red al cargar
document.addEventListener('DOMContentLoaded', function() {
    document.body.insertAdjacentHTML('beforeend', networkMenuHTML);
    
    // Eventos del menú
    document.getElementById('offline-mode').addEventListener('click', function() {
        document.getElementById('network-menu').style.display = 'none';
        isNetworkGame = false;
    });
    
    document.getElementById('online-mode').addEventListener('click', function() {
        document.getElementById('network-modes').style.display = 'none';
        document.getElementById('network-create-join').style.display = 'block';
        isNetworkGame = true;
        
        // Inicializar conexión con el servidor
        socket = io();
        
        // Configurar eventos de Socket.IO
        setupSocketEvents();
    });
    
    document.getElementById('create-game').addEventListener('click', function() {
        document.getElementById('create-game-options').style.display = 'block';
        document.getElementById('join-game-options').style.display = 'none';
    });
    
    document.getElementById('join-game').addEventListener('click', function() {
        document.getElementById('join-game-options').style.display = 'block';
        document.getElementById('create-game-options').style.display = 'none';
    });
    
    // Selección de modo de juego
    document.querySelectorAll('.game-mode-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.game-mode-btn').forEach(b => 
                b.style.background = '#e0e0e0');
            this.style.background = '#4CAF50';
            this.style.color = 'white';
            document.getElementById('start-network-game').style.display = 'inline-block';
        });
    });
    
    // Crear partida en red
    document.getElementById('start-network-game').addEventListener('click', function() {
        const selectedMode = document.querySelector('.game-mode-btn[style*="background: rgb(76, 175, 80)"]');
        if (selectedMode) {
            const players = parseInt(selectedMode.dataset.players);
            socket.emit('createGame', {
                gameMode: players,
                maxPlayers: players,
                activePlayerIndices: gameConfigs[players]
            });
        }
    });
    
    // Unirse a partida
    document.getElementById('join-game-btn').addEventListener('click', function() {
        const gameCode = document.getElementById('game-code-input').value.trim().toUpperCase();
        if (gameCode) {
            socket.emit('joinGame', gameCode);
        }
    });
});

// Mostrar una sala de espera mejorada con selección de jugadores
function showWaitingRoom(gameId, players) {
    const waitingRoomHTML = `
    <div id="network-waiting-room" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 200; display: flex; justify-content: center; align-items: center;">
        <div style="background: white; padding: 20px; border-radius: 10px; max-width: 600px; width: 90%; text-align: center;">
            <h2>Sala de espera - Planchís</h2>
            <p>Código de partida: <span id="game-code-display" style="font-weight: bold; font-size: 24px;">${gameId}</span></p>
            <p>Comparte este código con tus amigos para que se unan</p>
            
            <div style="margin: 20px 0;">
                <h3>Jugadores conectados</h3>
                <div id="player-slots" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin: 20px 0;">
                    ${generatePlayerSlots(players)}
                </div>
            </div>
            
            <div id="start-game-controls" style="margin-top: 20px; ${players.length > 1 ? '' : 'display: none;'}">
                <button id="start-network-game-btn" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">Iniciar Partida</button>
                <p id="waiting-message" style="font-style: italic; margin-top: 10px;">Esperando a que se unan más jugadores...</p>
            </div>
        </div>
    </div>`;
    
    // Eliminar sala de espera anterior si existe
    const oldWaitingRoom = document.getElementById('network-waiting-room');
    if (oldWaitingRoom) {
        oldWaitingRoom.remove();
    }
    
    // Añadir nueva sala de espera
    document.body.insertAdjacentHTML('beforeend', waitingRoomHTML);
    
    // Evento para iniciar partida
    document.getElementById('start-network-game-btn').addEventListener('click', function() {
        if (players.length >= 2) {
            socket.emit('startGame', {
                gameId: networkGameId
            });
        }
    });
    
    // Ocultar menú de red principal
    document.getElementById('network-menu').style.display = 'none';
    
    // Actualizar visibilidad del botón de inicio según jugadores
    updateStartGameButton(players.length);
    
    // Añadir eventos a los slots de jugadores
    setTimeout(() => {
        const slots = document.querySelectorAll('.player-slot');
        slots.forEach(slot => {
            const colorIndex = parseInt(slot.dataset.colorIndex);
            const isSelected = players.some(p => p.colorIndex === colorIndex);
            const isMe = players.some(p => p.colorIndex === colorIndex && p.id === socket.id);
            
            if (!isSelected || isMe) {
                slot.addEventListener('click', function() {
                    socket.emit('selectColor', {
                        gameId: networkGameId,
                        colorIndex: colorIndex
                    });
                });
            }
        });
    }, 100);
}

// Generar los slots para cada jugador
function generatePlayerSlots(connectedPlayers) {
    const playerColors = [
        { index: 0, name: 'Verde', color: '#00b050', bgColor: 'rgba(0, 176, 80, 0.2)' },
        { index: 1, name: 'Azul', color: '#1aa3ff', bgColor: 'rgba(26, 163, 255, 0.2)' },
        { index: 2, name: 'Rosa', color: '#ff1493', bgColor: 'rgba(255, 20, 147, 0.2)' },
        { index: 3, name: 'Amarillo', color: '#ffde00', bgColor: 'rgba(255, 222, 0, 0.2)' }
    ];
    
    let html = '';
    
    for (let i = 0; i < playerColors.length; i++) {
        const player = playerColors[i];
        const isSelected = connectedPlayers.some(p => p.colorIndex === i);
        const isMe = connectedPlayers.some(p => p.colorIndex === i && p.id === socket.id);
        
        html += `
        <div class="player-slot" data-color-index="${i}" style="
            width: 120px; 
            padding: 15px; 
            border: 3px solid ${player.color}; 
            border-radius: 10px;
            background-color: ${isSelected ? player.bgColor : 'white'};
            cursor: ${isSelected && !isMe ? 'not-allowed' : 'pointer'};
            position: relative;
        ">
            <div style="width: 30px; height: 30px; border-radius: 50%; background-color: ${player.color}; margin: 0 auto 10px;"></div>
            <div style="font-weight: bold;">${player.name}</div>
            <div style="margin-top: 5px; font-size: 14px;">
                ${isSelected 
                    ? (isMe 
                        ? 'Tú' 
                        : 'Ocupado') 
                    : 'Disponible'}
            </div>
            ${isMe ? '<div style="position: absolute; top: -10px; right: -10px; background: #4CAF50; color: white; border-radius: 50%; width: 25px; height: 25px; display: flex; justify-content: center; align-items: center; font-size: 14px;">✓</div>' : ''}
        </div>`;
    }
    
    return html;
}

// Actualizar la visibilidad del botón de inicio según jugadores
function updateStartGameButton(playerCount) {
    const startButton = document.getElementById('start-network-game-btn');
    const waitingMessage = document.getElementById('waiting-message');
    const startControls = document.getElementById('start-game-controls');
    
    if (!startButton || !waitingMessage || !startControls) return;
    
    startControls.style.display = playerCount > 1 ? 'block' : 'none';
    
    if (playerCount >= 2) {
        startButton.disabled = false;
        waitingMessage.textContent = '¡Ya puedes iniciar la partida!';
    } else {
        startButton.disabled = true;
        waitingMessage.textContent = 'Esperando a que se unan más jugadores...';
    }
}

// Actualizar la sala de espera con los jugadores conectados
function updateWaitingRoom(players) {
    const playerSlots = document.getElementById('player-slots');
    if (!playerSlots) return;
    
    playerSlots.innerHTML = generatePlayerSlots(players);
    
    // Añadir eventos a los slots de jugadores
    setTimeout(() => {
        const slots = document.querySelectorAll('.player-slot');
        slots.forEach(slot => {
            const colorIndex = parseInt(slot.dataset.colorIndex);
            const isSelected = players.some(p => p.colorIndex === colorIndex);
            const isMe = players.some(p => p.colorIndex === colorIndex && p.id === socket.id);
            
            if (!isSelected || isMe) {
                slot.addEventListener('click', function() {
                    socket.emit('selectColor', {
                        gameId: networkGameId,
                        colorIndex: colorIndex
                    });
                });
            }
        });
    }, 100);
    
    // Actualizar botón de inicio
    updateStartGameButton(players.length);
}

// Configurar eventos de Socket.IO
function setupSocketEvents() {
    // Lista de partidas disponibles
    socket.on('gamesList', function(gameIds) {
        const gamesContainer = document.getElementById('available-games');
        if (!gamesContainer) return;
        
        if (gameIds.length === 0) {
            gamesContainer.innerHTML = '<p style="text-align: center;">No hay partidas disponibles</p>';
            return;
        }
        
        gamesContainer.innerHTML = '<h4 style="text-align: center;">Partidas disponibles:</h4>';
        gameIds.forEach(gameId => {
            const gameBtn = document.createElement('button');
            gameBtn.textContent = gameId;
            gameBtn.style = "display: block; margin: 10px auto; padding: 8px 15px; background: #e0e0e0; border: none; border-radius: 5px; cursor: pointer;";
            gameBtn.addEventListener('click', () => {
                document.getElementById('game-code-input').value = gameId;
            });
            gamesContainer.appendChild(gameBtn);
        });
    });
    
    // Partida creada
    socket.on('gameCreated', function(data) {
        networkGameId = data.gameId;
        myPlayerIndex = data.playerIndex;
        
        // Ocultar opciones de creación y mostrar sala de espera
        document.getElementById('network-create-join').style.display = 'none';
        
        // Mostrar sala de espera con selección de jugadores
        showWaitingRoom(data.gameId, [{id: socket.id, colorIndex: 0}]);
    });
    
    // Unido a partida
    socket.on('gameJoined', function(data) {
        networkGameId = data.gameId;
        myPlayerIndex = data.playerIndex;
        
        // Ocultar opciones de unión y mostrar sala de espera
        document.getElementById('network-create-join').style.display = 'none';
        
        // Mostrar sala de espera con los jugadores actuales
        showWaitingRoom(data.gameId, data.players);
    });
    
    // Actualización de jugadores en sala de espera
    socket.on('playersUpdate', function(data) {
        // Actualizar sala de espera con los jugadores actuales
        updateWaitingRoom(data.players);
    });
    
    // Color seleccionado
    socket.on('colorSelected', function(data) {
        // Actualizar mi color si soy yo
        if (data.playerId === socket.id) {
            myPlayerIndex = data.colorIndex;
        }
        
        // Actualizar sala de espera
        updateWaitingRoom(data.players);
    });
    
    // Nuevo jugador unido
    socket.on('playerJoined', function(data) {
        // Actualizar sala de espera con el nuevo jugador
        updateWaitingRoom(data.players);
    });
    
    // Inicio de partida
    socket.on('gameStart', function(initialState) {
        // Ocultar sala de espera
        const waitingRoom = document.getElementById('network-waiting-room');
        if (waitingRoom) {
            waitingRoom.style.display = 'none';
        }
        
        // Ocultar menú de red
        document.getElementById('network-menu').style.display = 'none';
        document.getElementById('config-dialog').style.display = 'none';
        
        // Inicializar juego con el estado recibido
        gameState = initialState;
        initializeGameState();
        initializeBoard();
        initializePlayerInfo();
        
        logMessage("¡El juego en red ha comenzado!");
    });
    
    // Eventos del juego
    socket.on('diceRolled', function(data) {
        // Actualizar el resultado del dado en la interfaz
        const diceResult = data.diceResult;
        gameState.diceResult = diceResult;
        
        // Actualizar visualización del dado
        const diceResultElement = document.getElementById('dice-result');
        const elementInfoElement = document.getElementById('element-info');
        
        // Obtener el símbolo Unicode para el planeta
        const symbolObj = symbols.find(s => s.name === diceResult.planet);
        const symbolChar = symbolObj ? symbolObj.symbol : '?';
        
        // Mostrar el resultado en el dado
        diceResultElement.textContent = symbolChar;
        diceResultElement.className = 'dice-result';
        diceResultElement.classList.add(`circle-${diceResult.color}`);
        
        // Mostrar información del elemento
        elementInfoElement.textContent = `${diceResult.planet} - ${diceResult.element}`;
        
        // Calcular movimientos posibles en cada cliente
        findPossibleMoves();
        
        // Habilitar/deshabilitar botones según si es mi turno
        const isMyTurn = gameState.activePlayerIndices[gameState.currentPlayer] === myPlayerIndex;
        document.getElementById('roll-dice').disabled = true;
        document.getElementById('move-piece').disabled = !isMyTurn;
        document.getElementById('skip-turn').disabled = !isMyTurn || gameState.possibleMoves.length > 0;
        
        // Resaltar movimientos si es mi turno
        if (isMyTurn) {
            highlightPossibleMoves();
        }
        
        // Log
        const playerName = gameState.players[data.playerIndex].name;
        logMessage(`${playerName} ha tirado el dado: ${diceResult.planet} - ${diceResult.element} (${diceResult.color}).`);
    });
    
    socket.on('pieceMoved', function(data) {
        // Actualizar la posición de la ficha en todos los clientes
        const { playerIndex, pieceId, targetRow, targetCol } = data;
        
        // Si tengo la pieza seleccionada, deseleccionarla
        if (gameState.selectedPiece && gameState.selectedPiece.id === pieceId) {
            gameState.selectedPiece = null;
        }
        
        // Mover la ficha en el DOM y en el estado
        const piece = gameState.pieces.find(p => p.id === pieceId);
        if (piece) {
            // Actualizar en el DOM
            const pieceElement = document.getElementById(pieceId);
            if (pieceElement) {
                const oldCell = document.querySelector(`[data-row="${piece.row}"][data-col="${piece.col}"]`);
                const newCell = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
                
                if (oldCell && newCell) {
                    oldCell.removeChild(pieceElement);
                    newCell.appendChild(pieceElement);
                }
            }
            
            // Actualizar en el estado
            piece.row = targetRow;
            piece.col = targetCol;
            
            // Verificar si ha entrado en la cruz
            const targetCell = gameState.board.find(c => c.row === targetRow && c.col === targetCol);
            if (targetCell && targetCell.isInCross) {
                piece.inCross = true;
                gameState.players[playerIndex].piecesInCross++;
            }
            
            // Comprobar capturas (lo hace cada cliente)
            checkForCapturing(targetRow, targetCol);
            
            // Comprobar victoria
            const hasWon = gameState.players[playerIndex].piecesInCross >= 6;
            if (hasWon) {
                gameState.gameOver = true;
                logMessage(`¡${gameState.players[playerIndex].name} ha ganado la partida!`);
                alert(`¡${gameState.players[playerIndex].name} ha ganado la partida!`);
                
                // Desactivar controles
                document.getElementById('roll-dice').disabled = true;
                document.getElementById('move-piece').disabled = true;
                document.getElementById('skip-turn').disabled = true;
                return;
            }
            
            // Pasar al siguiente turno
            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.activePlayerIndices.length;
            
            // Actualizar indicador visual de jugador activo
            updatePlayerIndicator();
            
            // Habilitar/deshabilitar botones según turno
            const isMyTurn = gameState.activePlayerIndices[gameState.currentPlayer] === myPlayerIndex;
            document.getElementById('roll-dice').disabled = !isMyTurn;
            document.getElementById('move-piece').disabled = true;
            document.getElementById('skip-turn').disabled = true;
            
            // Limpiar resaltados
            clearHighlights();
            
            // Log
            const playerName = gameState.players[playerIndex].name;
            logMessage(`${playerName} ha movido una ficha a (${targetRow}, ${targetCol}).`);
            logMessage(`Turno de ${gameState.players[gameState.activePlayerIndices[gameState.currentPlayer]].name}.`);
        }
    });
    
    socket.on('turnChanged', function(data) {
        // Actualizar el turno
        gameState.currentPlayer = data.currentPlayer;
        
        // Actualizar indicador visual
        updatePlayerIndicator();
        
        // Habilitar/deshabilitar botones según turno
        const isMyTurn = gameState.activePlayerIndices[gameState.currentPlayer] === myPlayerIndex;
        document.getElementById('roll-dice').disabled = !isMyTurn;
        document.getElementById('move-piece').disabled = true;
        document.getElementById('skip-turn').disabled = true;
        
        // Log
        logMessage(`Turno de ${gameState.players[data.playerIndex].name}.`);
    });
    
    socket.on('playerDisconnected', function(data) {
        const playerName = gameState.players[data.playerIndex].name;
        logMessage(`${playerName} se ha desconectado.`);
    });
    
    socket.on('error', function(message) {
        alert("Error: " + message);
    });
}

function updatePlayerIndicator() {
    const playerInfoDivs = document.querySelectorAll('.player-info');
    playerInfoDivs.forEach(div => div.classList.remove('active'));
    playerInfoDivs[gameState.currentPlayer].classList.add('active');
}

// Modificar las funciones existentes para trabajar en red
// Versión en red de rollDice
const originalRollDice = rollDice;
rollDice = function() {
    if (isNetworkGame) {
        // En modo red, enviar acción al servidor
        if (networkGameId) {
            socket.emit('gameAction', {
                gameId: networkGameId,
                action: 'rollDice'
            });
        }
    } else {
        // En modo local, usar la función original
        originalRollDice();
    }
};

// Versión en red de handleCellClick
const originalHandleCellClick = handleCellClick;
handleCellClick = function(row, col) {
    if (isNetworkGame) {
        // Verificar que sea mi turno
        const isMyTurn = gameState.activePlayerIndices[gameState.currentPlayer] === myPlayerIndex;
        if (!isMyTurn) return;
        
        // En modo red, validar y enviar al servidor
        // Si hay una ficha seleccionada, intentar moverla
        if (gameState.selectedPiece) {
            const validMove = gameState.possibleMoves.find(m => 
                m.pieceId === gameState.selectedPiece.id && 
                m.targetRow === row && 
                m.targetCol === col
            );
            
            if (validMove) {
                socket.emit('gameAction', {
                    gameId: networkGameId,
                    action: 'movePiece',
                    payload: {
                        pieceId: gameState.selectedPiece.id,
                        targetRow: row,
                        targetCol: col
                    }
                });
                
                // Limpiar selección
                clearHighlights();
                gameState.selectedPiece = null;
                return;
            }
        }
        
        // Si llegamos aquí, seguir con la lógica normal de selección
        const clickedPiece = gameState.pieces.find(p => 
            p.player === myPlayerIndex && 
            p.row === row && 
            p.col === col && 
            !p.inCross
        );
        
        if (clickedPiece) {
            // Seleccionar esta ficha
            if (gameState.selectedPiece) {
                // Quitar selección previa
                const pieceElement = document.getElementById(gameState.selectedPiece.id);
                if (pieceElement) {
                    pieceElement.classList.remove('selected-piece');
                }
            }
            
            gameState.selectedPiece = clickedPiece;
            
            // Verificar si tiene movimientos válidos
            const hasValidMoves = gameState.possibleMoves.some(m => 
                m.type === 'normal' && m.pieceId === clickedPiece.id
            );
            
            if (hasValidMoves) {
                // Resaltar los movimientos posibles
                highlightPossibleMovesForPiece(clickedPiece);
                
                // Añadir clase visual
                const pieceElement = document.getElementById(clickedPiece.id);
                if (pieceElement) {
                    pieceElement.classList.add('selected-piece');
                }
            } else {
                gameState.selectedPiece = null;
                logMessage("Esta ficha no tiene movimientos válidos.");
            }
        } else {
            // Si no hay ficha, verificar si es un movimiento desde casa
            const moveFromHouse = gameState.possibleMoves.find(m => 
                m.type === 'fromHouse' && 
                m.targetRow === row && 
                m.targetCol === col
            );
            
            if (moveFromHouse && gameState.players[myPlayerIndex].piecesInHouse > 0) {
                socket.emit('gameAction', {
                    gameId: networkGameId,
                    action: 'placeFromHouse',
                    payload: {
                        targetRow: row,
                        targetCol: col
                    }
                });
                
                // Limpiar resaltados
                clearHighlights();
            }
        }
    } else {
        // En modo local, usar la función original
        originalHandleCellClick(row, col);
    }
};

// Versión en red para manejar clic en casa
const originalHandleHouseSymbolClick = handleHouseSymbolClick;
handleHouseSymbolClick = function(playerIndex) {
    if (isNetworkGame) {
        // Verificar que sea mi turno y que el índice coincida con mi índice de jugador
        const isMyTurn = gameState.activePlayerIndices[gameState.currentPlayer] === myPlayerIndex;
        if (!isMyTurn || playerIndex !== myPlayerIndex) return;
        
        // Seguir con la lógica normal para el modo en red
        if (gameState.diceResult && gameState.players[myPlayerIndex].piecesInHouse > 0) {
            const fromHouseMoves = gameState.possibleMoves.filter(m => m.type === 'fromHouse');
            
            if (fromHouseMoves.length > 0) {
                // Limpiar resaltados
                clearHighlights();
                
                // Resaltar los destinos posibles
                for (const move of fromHouseMoves) {
                    const cell = document.querySelector(`.cell[data-row="${move.targetRow}"][data-col="${move.targetCol}"]`);
                    if (cell) {
                        cell.classList.add('highlight-move');
                    }
                }
                
                // Indicar visualmente que se ha seleccionado la casa
                const symbolDiv = document.querySelector(`.house-symbol[data-house="${playerIndex}"]`);
                if (symbolDiv) {
                    symbolDiv.classList.add('selected-house');
                }
                
                // Activar modo de casa seleccionada
                gameState.houseSelected = true;
                
                logMessage("Casa seleccionada. Haz clic en una casilla resaltada para colocar tu ficha.");
            } else {
                logMessage("No hay movimientos posibles desde casa con el dado actual.");
            }
        }
    } else {
        // En modo local, usar la función original
        originalHandleHouseSymbolClick(playerIndex);
    }
};

// Versión en red de la función pasar turno
const originalSkipTurn = document.getElementById('skip-turn').onclick;
document.getElementById('skip-turn').addEventListener('click', function() {
    if (isNetworkGame) {
        // Verificar que sea mi turno
        const isMyTurn = gameState.activePlayerIndices[gameState.currentPlayer] === myPlayerIndex;
        if (isMyTurn && gameState.diceResult) {
            socket.emit('gameAction', {
                gameId: networkGameId,
                action: 'skipTurn'
            });
            
            // Limpiar estado
            clearHighlights();
            gameState.selectedPiece = null;
        }
    } else if (originalSkipTurn) {
        // Si existe una función original, llamarla
        originalSkipTurn();
    }
});
</script>
<body>
    <div class="title-container">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Creator: Pedro -->
<svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" width="50mm" height="50mm" version="1.1" style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd"
viewBox="0 0 45000 45000"
 xmlns:xlink="http://www.w3.org/1999/xlink">
 <defs>
  <style type="text/css">
   <![CDATA[
    .str1 {stroke:black;stroke-width:150;stroke-miterlimit:22.9256}
    .str0 {stroke:black;stroke-width:20;stroke-miterlimit:22.9256}
    .fil1 {fill:#FFED00}
    .fil0 {fill:#393185}
    .fil2 {fill:black;fill-rule:nonzero}
   ]]>
  </style>
 </defs>
 <g id="Capa_x0020_1">
  <metadata id="Pedro"/>
  <circle class="fil0 str0" transform="matrix(6.32185 -3.64992 3.64992 6.32185 22072.2 23446.2)" r="1932.62"/>
 </g>
 <g id="Copia_x0020_de_x0020_Copia_x0020_de_x0020_Copia_x0020_de_x0020_Capa_x0020_4">
  <metadata id="Pedro"/>
  <g id="Pedro">
   <polygon class="fil1 str1" points="22072.23,9524.87 24905.53,18539.07 34128.48,16485.55 27738.52,23446.24 34128.48,30406.93 24905.53,28353.41 22072.23,37367.61 19238.93,28353.41 10015.98,30406.93 16405.94,23446.24 10015.98,16485.55 19238.93,18539.07 "/>
   <polygon class="fil1 str1" points="22072.23,2377.72 22780.55,4631.28 25086.29,4117.9 23488.8,5858.07 25086.29,7598.24 22780.55,7084.86 22072.23,9338.41 21363.9,7084.86 19058.17,7598.24 20655.66,5858.07 19058.17,4117.9 21363.9,4631.28 "/>
   <polygon class="fil1 str1" points="30867.74,4731.63 31576.06,6985.18 33881.8,6471.8 32284.31,8211.98 33881.8,9952.15 31576.06,9438.77 30867.74,11692.32 30159.41,9438.77 27853.68,9952.15 29451.17,8211.98 27853.68,6471.8 30159.41,6985.18 "/>
   <polygon class="fil1 str1" points="37306.57,11170.39 38014.89,13423.94 40320.63,12910.56 38723.14,14650.73 40320.63,16390.9 38014.89,15877.52 37306.57,18131.07 36598.24,15877.52 34292.51,16390.9 35889.99,14650.73 34292.51,12910.56 36598.24,13423.94 "/>
   <polygon class="fil1 str1" points="39660.4,19965.9 40368.73,22219.45 42674.46,21706.07 41076.97,23446.24 42674.46,25186.41 40368.73,24673.03 39660.4,26926.58 38952.08,24673.03 36646.34,25186.41 38243.83,23446.24 36646.34,21706.07 38952.08,22219.45 "/>
   <polygon class="fil1 str1" points="37306.57,28761.48 38014.89,31015.03 40320.63,30501.65 38723.14,32241.82 40320.63,33981.99 38014.89,33468.62 37306.57,35722.17 36598.24,33468.62 34292.51,33981.99 35889.99,32241.82 34292.51,30501.65 36598.24,31015.03 "/>
   <polygon class="fil1 str1" points="30867.74,35200.31 31576.06,37453.86 33881.8,36940.48 32284.31,38680.65 33881.8,40420.82 31576.06,39907.44 30867.74,42160.99 30159.41,39907.44 27853.68,40420.82 29451.17,38680.65 27853.68,36940.48 30159.41,37453.86 "/>
   <polygon class="fil1 str1" points="22072.23,37554.07 22780.55,39807.62 25086.29,39294.24 23488.8,41034.41 25086.29,42774.58 22780.55,42261.21 22072.23,44514.76 21363.9,42261.21 19058.17,42774.58 20655.66,41034.41 19058.17,39294.24 21363.9,39807.62 "/>
   <polygon class="fil1 str1" points="13276.65,35200.31 13984.97,37453.86 16290.71,36940.48 14693.22,38680.65 16290.71,40420.82 13984.97,39907.44 13276.65,42160.99 12568.32,39907.44 10262.58,40420.82 11860.07,38680.65 10262.58,36940.48 12568.32,37453.86 "/>
   <polygon class="fil1 str1" points="6837.89,28761.48 7546.22,31015.03 9851.95,30501.65 8254.46,32241.82 9851.95,33981.99 7546.22,33468.62 6837.89,35722.17 6129.57,33468.62 3823.83,33981.99 5421.32,32241.82 3823.83,30501.65 6129.57,31015.03 "/>
   <polygon class="fil1 str1" points="4484.06,19965.9 5192.38,22219.45 7498.12,21706.07 5900.63,23446.24 7498.12,25186.41 5192.38,24673.03 4484.06,26926.58 3775.73,24673.03 1469.99,25186.41 3067.48,23446.24 1469.99,21706.07 3775.73,22219.45 "/>
   <polygon class="fil1 str1" points="6837.89,11170.39 7546.22,13423.94 9851.95,12910.56 8254.46,14650.73 9851.95,16390.9 7546.22,15877.52 6837.89,18131.07 6129.57,15877.52 3823.83,16390.9 5421.32,14650.73 3823.83,12910.56 6129.57,13423.94 "/>
   <polygon class="fil1 str1" points="13276.65,4731.63 13984.97,6985.18 16290.71,6471.8 14693.22,8211.98 16290.71,9952.15 13984.97,9438.77 13276.65,11692.32 12568.32,9438.77 10262.58,9952.15 11860.07,8211.98 10262.58,6471.8 12568.32,6985.18 "/>
  </g>
 </g>
 <g id="Capa_x0020_2">
  <metadata id="Pedro"/>
  <path class="fil2" d="M13498.85 27149.78l-63.5 -110.53c281.63,-148.16 500.94,-266.94 656.75,-357.48l496.83 -296.92c149.35,-85.84 276.35,-138.18 381.01,-156.41 105.24,-17.63 208.72,0.01 311.61,53.52 102.31,53.5 188.15,140.52 257.54,260.46 111.7,193.45 137.58,389.82 78.78,590.32 -59.39,200.5 -202.85,366.89 -430.98,498.59 -70.55,40.57 -163.45,82.9 -278.11,127 155.81,265.17 245.78,418.63 269.88,460.38l61.15 109.94c55.26,95.25 95.84,148.17 122.89,157.58 44.09,17.05 151.1,-10.59 319.85,-82.9 19.4,-8.82 48.21,-20.58 87.01,-36.45l63.5 110.52c-291.04,153.46 -499.18,266.36 -625.59,339.26 -146.4,84.67 -329.26,197.56 -549.75,339.26l-64.09 -109.95c157.58,-132.29 241.07,-212.85 251.06,-242.83 10,-29.4 2.95,-69.97 -21.16,-120.53 -24.1,-51.16 -176.39,-322.8 -456.26,-814.91l-262.82 -450.98c-105.84,-181.68 -171.1,-286.34 -195.2,-314.56 -24.7,-28.22 -50.56,-44.09 -78.79,-46.44 -35.87,-2.95 -122.3,19.98 -258.71,68.2 -16.46,6.46 -40.56,15.29 -72.9,25.86zm1312.34 439.81c64.08,-28.81 118.18,-56.46 161.68,-81.74 115.24,-66.44 185.21,-153.45 208.73,-261.63 24.11,-107.6 -6.46,-235.78 -92.31,-383.95 -75.84,-131.7 -165.22,-212.25 -267.52,-243.42 -102.9,-30.56 -212.85,-12.34 -330.43,55.27 -44.7,25.88 -94.08,61.16 -147.59,105.24l467.44 810.23z"/>
  <path id="1" class="fil2" d="M15407.14 26047.94l-64.09 -109.95c261.05,-136.4 462.72,-245.17 605.02,-327.49 145.22,-83.49 335.14,-201.08 570.91,-351.6l63.5 110.54c-186.98,149.34 -286.93,233.41 -299.86,252.82 -20,34.11 -10,85.84 30.57,155.22l216.96 386.29 716.14 1241.19 543.27 -313.38c89.38,-51.74 145.82,-92.31 168.75,-121.71 30.58,-40.57 52.91,-93.48 65.26,-158.75 12.35,-65.85 20.59,-205.78 24.11,-419.81l134.06 -77.6c39.98,222.24 91.13,462.13 154.63,718.49 -429.21,233.42 -783.75,430.39 -1064.21,592.67 -229.9,132.29 -465.08,275.75 -706.74,429.8l-63.5 -110.54c156.99,-137 240.48,-216.96 251.06,-240.48 10.01,-22.93 7.65,-53.5 -8.22,-91.73 -15.88,-37.62 -151.7,-277.51 -406.29,-719.07l-315.15 -542.1 -55.26 -95.25c-91.72,-159.34 -152.29,-251.65 -181.68,-276.93 -21.76,-19.41 -44.69,-28.23 -69.97,-26.46 -24.7,1.76 -127.59,33.51 -309.27,95.83z"/>
  <path id="2" class="fil2" d="M19914.37 26120.85l-63.5 -110.54c107.59,-91.13 166.98,-149.34 177.56,-174.03 11.17,-24.7 9.41,-49.39 -4.11,-72.91 -8.23,-14.11 -20.58,-28.23 -36.46,-42.92 -39.98,-32.34 -164.04,-127.59 -372.18,-286.34 -142.28,78.2 -259.88,144.05 -353.36,198.15 -76.44,44.1 -203.44,119.35 -381.01,225.77 40.58,324.55 67.63,499.19 81.73,523.88 14.12,24.1 32.34,37.05 54.68,39.39 22.35,1.76 103.48,-21.17 242.24,-69.37l64.09 109.94c-131.7,61.74 -255.18,125.24 -369.23,191.09 -123.48,71.73 -245.78,149.34 -366.3,234.01l-64.1 -110.54c78.79,-70.56 128.18,-127.58 148.17,-171.1 13.52,-29.4 20.58,-65.26 21.17,-107.6 2.93,-85.25 -21.76,-394.52 -72.32,-928.98 -32.34,-338.07 -86.43,-834.32 -162.28,-1489.31l120.53 -69.97c227.55,180.51 670.87,505.65 1329.97,976.62 366.31,262.23 579.15,408.04 639.12,438.61 41.16,21.17 77.03,32.34 107.01,33.52 29.99,1.17 111.71,-16.46 245.19,-54.09l63.49 110.53c-182.27,90.54 -348.66,179.92 -499.77,266.94 -149.35,85.84 -332.79,199.31 -550.33,339.25zm-1163 -1352.9l101.14 877.83 296.33 -168.75c70.55,-40.57 171.68,-99.95 303.39,-176.97l-700.86 -532.11z"/>
  <path id="3" class="fil2" d="M19819.9 23500.59l-63.5 -110.53c142.29,-67.62 272.23,-135.23 389.83,-203.44 118.17,-68.2 254.58,-154.05 408.04,-257.53 215.78,93.49 840.78,333.38 1876.19,720.85l-474.49 -807.86c-119.35,-195.21 -190.5,-301.04 -214.02,-316.92 -23.52,-16.46 -50.57,-24.11 -81.72,-22.93 -31.16,1.77 -124.06,34.1 -279.87,97.01l-63.5 -109.95c166.39,-81.72 309.26,-156.98 428.63,-225.77 115.23,-66.44 259.28,-156.98 431.55,-271.64l64.09 110.53c-27.63,24.11 -48.21,41.16 -61.74,51.74 -107,85.85 -165.8,145.82 -176.38,180.51 -10.59,34.69 1.17,86.43 35.86,155.22 70.56,144.64 231.07,433.92 481.55,867.84 160.51,278.1 349.83,593.25 567.38,944.86 -38.8,41.15 -75.25,84.08 -110.54,129.34l-976.6 -386.29 -1468.15 -550.92 413.93 706.15 409.81 682.04c32.92,49.97 56.44,79.96 71.14,89.37 14.7,9.4 31.16,14.11 48.21,14.7 29.4,0 109.96,-22.93 242.25,-69.97 15.28,-6.47 38.22,-14.11 69.38,-24.7l64.08 110.54c-177.56,88.19 -318.09,161.69 -421.57,221.66 -88.19,50.57 -235.18,142.88 -440.97,276.35l-63.5 -110.54c27.05,-23.52 48.22,-41.75 62.33,-54.09 104.06,-83.49 161.68,-140.53 174.03,-169.92 7.65,-18.82 8.82,-40.58 2.94,-64.09 -5.88,-24.11 -84.66,-175.8 -236.95,-455.09 -219.3,-405.11 -411.57,-750.24 -576.2,-1035.99 -55.27,-95.25 -95.84,-153.46 -121.71,-174.03 -25.87,-21.17 -56.45,-31.17 -92.31,-30.58 -35.28,0.59 -113.48,22.34 -234.01,65.85 -18.81,6.46 -46.45,15.87 -83.49,28.22z"/>
  <path id="4" class="fil2" d="M25257.06 22489l158.75 99.37c-106.42,212.85 -218.72,385.12 -337.49,516.23 -118.18,131.7 -256.94,242.83 -416.28,335.14 -335.73,194.02 -655.58,251.06 -958.38,170.51 -302.8,-80.55 -547.98,-282.81 -735.54,-606.78 -198.15,-343.96 -249.89,-683.8 -154.05,-1018.94 95.26,-335.14 334.56,-612.66 717.32,-833.73 122.3,-70.56 246.35,-129.35 371.59,-175.81 124.65,-46.44 286.34,-91.71 485.07,-135.81 31.16,68.2 67.03,136.99 107.59,206.37 69.38,120.53 161.7,263.41 276.94,428.63l-164.05 94.66c-159.93,-162.28 -257.52,-255.18 -292.21,-278.69 -79.96,-53.51 -176.98,-81.73 -290.45,-84.67 -114.07,-2.94 -242.84,36.45 -385.71,119.35 -217.54,125.83 -347.49,289.28 -388.64,490.96 -51.16,242.82 5.29,505.06 168.15,787.87 168.75,292.21 368.66,473.31 599.72,543.86 230.49,69.97 466.85,35.28 708.5,-104.07 215.2,-124.06 391.59,-308.68 529.17,-554.45z"/>
  <path id="5" class="fil2" d="M24605.72 20737.17l-63.51 -110.53c186.39,-92.91 372.78,-192.86 558.57,-300.46 194.03,-111.71 382.77,-228.13 566.21,-348.66l63.5 110.54c-135.82,112.88 -214.02,182.85 -233.42,209.31 -20,27.05 -28.23,55.27 -24.7,84.67 2.94,29.98 39.99,105.83 109.95,226.96l60.56 102.29 219.9 383.95c144.64,-76.44 296.93,-161.1 458.02,-254 145.23,-84.08 270.46,-159.92 376.3,-227.54l-308.68 -527.41c-54.68,-94.66 -94.66,-150.51 -119.35,-168.15 -24.7,-17.65 -55.87,-23.52 -93.5,-17.64 -29.39,4.11 -124.65,35.86 -285.15,95.25l-63.5 -110.54c198.14,-99.95 377.47,-196.38 538.57,-289.28 151.11,-87.6 346.9,-207.55 586.2,-359.83l63.5 109.95 -208.14 188.15c-21.75,21.75 -34.69,40.57 -39.39,56.44 -4.7,15.87 -5.3,32.93 -1.77,50.56 8.82,38.81 62.33,145.23 160.51,319.27 156.4,275.76 258.71,455.09 306.93,538.57 196.37,340.44 343.36,589.14 441.55,747.9 32.93,52.32 67.03,82.9 102.32,91.13 35.27,7.63 125.23,-15.87 269.28,-71.15l63.5 -24.69 63.5 110.54c-215.79,109.95 -406.29,212.26 -570.33,307.5 -162.28,93.49 -346.9,207.55 -554.45,341.61l-63.5 -110.54 221.08 -195.2c24.11,-27.05 36.45,-54.69 37.04,-82.32 1.17,-27.04 -19.4,-77.02 -60.56,-148.75l-375.71 -660.28 -413.34 231.06c-19.4,10.59 -159.34,94.07 -420.39,250.47 235.77,406.29 379.23,647.36 429.8,724.38 28.22,41.16 58.8,65.26 92.31,71.73 34.1,7.05 120.53,-17.06 259.88,-71.74 15.29,-6.46 38.22,-15.28 69.96,-27.04l64.1 110.53c-227.55,116.42 -428.63,225.2 -603.25,326.33 -179.92,104.07 -353.96,211.66 -521.53,323.38l-64.09 -110.54c121.71,-106.42 194.62,-172.86 217.55,-199.32 22.93,-26.46 34.69,-54.09 34.69,-82.31 0,-28.81 -20.58,-79.38 -62.91,-152.29l-329.85 -585.02c-175.21,-303.39 -326.32,-561.51 -453.32,-774.34 -61.74,-105.26 -108.18,-166.41 -139.94,-184.04 -18.22,-11.77 -41.74,-15.88 -69.96,-12.93 -28.23,2.94 -125.24,34.09 -291.04,94.07z"/>
  <path id="6" class="fil2" d="M28121.41 18560.23l63.5 110.54 -51.16 39.4c-122.88,92.3 -190.5,158.16 -203.43,196.96 -12.35,39.39 1.18,92.9 40.57,161.69l31.16 53.51 285.75 501.54 331.03 570.31 169.92 290.46c49.39,85.25 84.08,136.41 105.24,153.46 21.17,17.05 45.28,25.28 72.91,24.11 46.45,-1.78 130.53,-25.87 252.24,-72.32 13.52,-5.3 33.51,-12.94 60.56,-22.93l63.5 110.53c-209.91,106.43 -392.76,204.61 -547.98,293.98 -147,85.26 -338.67,203.44 -575.03,354.55l-64.09 -110.54c138.76,-118.77 214.02,-185.21 225.19,-199.33 17.63,-22.34 27.64,-45.27 29.99,-69.38 1.76,-31.15 -17.64,-82.89 -57.03,-154.04 -93.49,-165.81 -254.59,-447.44 -483.9,-844.32l-318.09 -540.34 -25.86 -44.68c-45.87,-79.96 -87.03,-124.06 -122.9,-134.05 -35.86,-9.41 -125.82,12.34 -269.87,66.44 -16.46,5.87 -40.57,13.52 -71.73,23.51l-64.09 -110.53c262.23,-136.4 456.85,-241.65 583.85,-315.15 136.4,-78.2 316.33,-189.33 539.75,-333.38zm-582.67 -546.8l41.75 27.63c-65.27,232.83 -123.48,479.19 -174.04,739.07l-131.11 75.85 -121.13 -620.3c101.72,-53.51 168.75,-89.37 201.67,-108.77 37.05,-21.17 97.61,-58.8 182.86,-113.48z"/>
  <path id="7" class="fil2" d="M29985.05 18291.83l-148.76 85.84c-143.46,-171.68 -266.92,-271.05 -371,-297.51 -104.65,-27.04 -214.02,-7.05 -328.08,58.8 -102.31,59.38 -166.98,131.7 -193.44,218.14 -26.46,86.43 -15.88,170.5 31.74,252.82 42.93,74.08 107.61,125.23 194.63,154.63 87.6,29.98 256.34,32.93 506.24,8.24 249.29,-25.29 442.14,-10.59 577.96,44.09 136.41,54.68 247.53,156.4 333.37,304.57 103.49,179.32 126.42,375.12 69.38,587.37 -57.03,212.84 -235.18,405.69 -535.63,579.15 -107.6,61.73 -213.43,112.3 -318.09,151.69 -78.79,31.17 -182.26,59.97 -309.86,87.01 -84.07,-184.61 -175.2,-362.18 -273.4,-532.1l-57.62 -99.96 145.82 -84.07c152.28,175.79 275.16,281.04 369.83,315.74 126.41,47.03 256.35,32.93 388.64,-43.51 105.24,-61.16 171.68,-141.12 199.32,-240.48 27.05,-99.37 12.93,-197.55 -43.51,-295.16 -35.28,-61.73 -80.55,-108.78 -134.06,-141.11 -54.09,-32.93 -118.17,-53.51 -192.85,-61.74 -74.67,-8.82 -198.73,-5.28 -372.77,10 -268.69,22.34 -465.08,8.24 -590.31,-42.92 -124.06,-50.57 -222.25,-137.59 -293.98,-261.64 -105.84,-183.45 -125.82,-373.95 -59.97,-572.09 65.85,-198.73 225.77,-371.59 480.36,-518.59 169.33,-97.61 371.59,-171.09 606.78,-220.48 84.08,159.34 143.46,269.29 178.74,330.43 40.57,70.56 87.6,144.64 140.52,222.84z"/>
 </g>
</svg>
        <h1></h1>
    </div>    
    <!-- Diálogo de configuración (se muestra al inicio) -->
    <div class="config-dialog" id="config-dialog">
        <div class="config-container">
            <h2 class="config-title">Configuración del Juego</h2>
            
            <div class="game-mode">
                <h3>Modo de Juego</h3>
                <div class="mode-selector">
                    <div class="mode-button selected" data-players="2" id="mode-2">2 Jugadores</div>
                    <div class="mode-button" data-players="4" id="mode-4">4 Jugadores</div>
                </div>
            </div>
            
            <div class="config-option">
                <h3>Selecciona los Jugadores Humanos</h3>
                <div class="player-selector" id="player-selector">
                    <!-- Las opciones de jugadores se generarán dinámicamente -->
                </div>
            </div>
            
            <button class="start-button" id="start-game">Comenzar Juego</button>
        </div>
    </div>
    
    <div class="game-container">
        <div class="game-info" id="game-info">
            <!-- Información de jugadores generada dinámicamente -->
        </div>
        
        <div class="game-board" id="board">
            <!-- El tablero se generará dinámicamente -->
        </div>
        
        <div class="controls">
            <div class="dice-container">
                <div class="dice">
                    <div class="dice-result" id="dice-result"></div>
                </div>
                <div id="element-info" class="element-info"></div>
                <button id="roll-dice">Tirar Dado</button>
                <button id="move-piece" disabled>Mover Ficha</button>
                <button id="skip-turn" disabled>Pasar Turno</button>
            </div>
        </div>
        
        <div class="message-log" id="message-log">
            <div class="log-entry">Configura el juego para comenzar.</div>
        </div>
    </div>

    <script>
        // Función de utilidad para depuración
        function debug(message) {
            console.log(`[DEBUG] ${message}`);
        }

        // Al cargar la página, asegurarse de que el modo predeterminado esté configurado
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializar en modo 2 jugadores por defecto
            debug("Inicializando juego en modo 2 jugadores por defecto");
            gameState.gameMode = 2;
            gameState.humanPlayers = [0]; // Jugador 1 (Verde) es humano por defecto
            gameState.activePlayerIndices = gameConfigs[2];
            
            // Generar selector de jugadores inicial
            generatePlayerSelector();
        });

        // Definir los símbolos planetarios 
        const symbols = [
            { name: 'Sol', symbol: '☉' },
            { name: 'Luna', symbol: '☽' },
            { name: 'Mercurio', symbol: '☿' },
            { name: 'Venus', symbol: '♀' },
            { name: 'Marte', symbol: '♂' },
            { name: 'Júpiter', symbol: '♃' },
            { name: 'Saturno', symbol: '♄' },
            { name: 'Sol_Rojo', symbol: '☉' },
            { name: 'Luna_Amarillo', symbol: '☽' },
            { name: 'Mercurio_Amarillo', symbol: '☿' },
            { name: 'Venus_Amarillo', symbol: '♀' },
            { name: 'Marte_Azul', symbol: '♂' },
            { name: 'Júpiter_Azul', symbol: '♃' },
            { name: 'Sol_Verde', symbol: '☉' },
            { name: 'Luna_Azul', symbol: '☽' },
            { name: 'Mercurio_Verde', symbol: '☿' },
            { name: 'Venus_Verde', symbol: '♀' },
            { name: 'Marte_Rojo', symbol: '♂' },
            { name: 'Júpiter_Rojo', symbol: '♃' }
        ];
        
        // Definir las combinaciones del dado (12 posibilidades)
        const dadoCombinations = [
            { planet: 'Marte_Rojo', element: 'Fuego', color: 'red' },
            { planet: 'Marte_Azul', element: 'Agua', color: 'blue' },
            { planet: 'Júpiter_Rojo', element: 'Fuego', color: 'red' },
            { planet: 'Júpiter_Azul', element: 'Agua', color: 'blue' },
            { planet: 'Venus_Verde', element: 'Tierra', color: 'green' },
            { planet: 'Venus_Amarillo', element: 'Aire', color: 'yellow' },
            { planet: 'Mercurio_Verde', element: 'Tierra', color: 'green' },
            { planet: 'Mercurio_Amarillo', element: 'Aire', color: 'yellow' },
            { planet: 'Luna_Azul', element: 'Agua', color: 'blue' },
            { planet: 'Luna_Amarillo', element: 'Aire', color: 'yellow' },
            { planet: 'Sol_Rojo', element: 'Fuego', color: 'red' },
            { planet: 'Sol_Verde', element: 'Tierra', color: 'green' }
        ];
        
        // Definición de las líneas del tablero
        const boardLines = {
            "Rojo_Humedo": { type: "vertical", col: 6, minRow: 0, maxRow: 5 },
            "Rojo_Seco": { type: "horizontal", row: 6, minCol: 0, maxCol: 5 },
            "Amarillo_Humedo": { type: "horizontal", row: 8, minCol: 0, maxCol: 5 },
            "Amarillo_Seco": { type: "vertical", col: 6, minRow: 9, maxRow: 14 },
            "Verde_Humedo": { type: "vertical", col: 8, minRow: 9, maxRow: 14 },
            "Verde_Seco": { type: "horizontal", row: 8, minCol: 9, maxCol: 14 },
            "Azul_Humedo": { type: "horizontal", row: 6, minCol: 9, maxCol: 14 },
            "Azul_Seco": { type: "vertical", col: 8, minRow: 0, maxRow: 5 }
        };

        // Definición de las adyacencias entre líneas
        const adjacentLines = {
            "Rojo_Humedo": ["Rojo_Seco", "Azul_Seco"],
            "Rojo_Seco": ["Rojo_Humedo", "Amarillo_Humedo"],
            "Amarillo_Humedo": ["Rojo_Seco", "Amarillo_Seco"],
            "Amarillo_Seco": ["Amarillo_Humedo", "Verde_Humedo"],
            "Verde_Humedo": ["Amarillo_Seco", "Verde_Seco"],
            "Verde_Seco": ["Verde_Humedo", "Azul_Humedo"],
            "Azul_Humedo": ["Verde_Seco", "Azul_Seco"],
            "Azul_Seco": ["Azul_Humedo", "Rojo_Humedo"]
        };
        
        // Mapeo de casas de cada jugador a las líneas iniciales
        const playerStartLines = {
            0: ["Verde_Humedo", "Verde_Seco"], // Jugador 1 (Verde)
            1: ["Azul_Humedo", "Azul_Seco"],   // Jugador 2 (Azul)
            2: ["Rojo_Humedo", "Rojo_Seco"],   // Jugador 3 (Rosa)
            3: ["Amarillo_Humedo", "Amarillo_Seco"] // Jugador 4 (Amarillo)
        };
        
        // Mapeo de zonas de cruz para ganar
        const playerCrossZones = {
            0: { type: "vertical", col: 7, minRow: 8, maxRow: 13, color: "green" }, // Jugador 1 (Verde)
            1: { type: "horizontal", row: 7, minCol: 8, maxCol: 13, color: "blue" }, // Jugador 2 (Azul)
            2: { type: "vertical", col: 7, minRow: 1, maxRow: 6, color: "pink" }, // Jugador 3 (Rosa)
            3: { type: "horizontal", row: 7, minCol: 1, maxCol: 6, color: "yellow" } // Jugador 4 (Amarillo)
        };

        // Lista de posiciones donde debe aparecer Saturno con fondo azul oscuro
        const saturnPositions = [
            { row: 6, col: 6 },
            { row: 6, col: 8 },
            { row: 8, col: 6 },
            { row: 8, col: 8 }
        ];
        
        // Definición de las casas con sus propiedades
        const houseZones = [
            { 
                name: "pink", 
                startRow: 0, 
                startCol: 0, 
                size: 5,
                symbol: "sun", 
                color: "#ff1493"
            },
            { 
                name: "blue", 
                startRow: 0, 
                startCol: 10, 
                size: 5,
                symbol: "moon", 
                color: "#1aa3ff"
            },
            { 
                name: "yellow", 
                startRow: 10, 
                startCol: 0, 
                size: 5,
                symbol: "moon", 
                color: "#ffde00"
            },
            { 
                name: "green", 
                startRow: 10, 
                startCol: 10, 
                size: 5,
                symbol: "sun", 
                color: "#00b050"
            }
        ];
        
        // Información de los jugadores
        const playerInfo = [
            { name: 'Jugador 1', color: 'player1', colorName: 'Verde', colorHex: '#00b050', crossZone: 'green' },
            { name: 'Jugador 2', color: 'player2', colorName: 'Azul', colorHex: '#1aa3ff', crossZone: 'blue' },
            { name: 'Jugador 3', color: 'player3', colorName: 'Rosa', colorHex: '#ff1493', crossZone: 'pink' },
            { name: 'Jugador 4', color: 'player4', colorName: 'Amarillo', colorHex: '#ffde00', crossZone: 'yellow' }
        ];
        
        // Configuración para modos de 2 y 4 jugadores
        const gameConfigs = {
            2: [0, 2], // Verde y Rosa (opuestos)
            4: [0, 1, 2, 3] // Todos los jugadores
        };
        
        // Definición de casillas seguras para cada jugador (en modo 4 jugadores)
        const safeSpots = {
            0: [  // Jugador 1 (Verde)
                { planet: 'Mercurio_Verde', color: 'green' },
                { planet: 'Venus_Verde', color: 'green' }
            ],
            1: [  // Jugador 2 (Azul)
                { planet: 'Marte_Azul', color: 'blue' },
                { planet: 'Júpiter_Azul', color: 'blue' }
            ],
            2: [  // Jugador 3 (Rosa)
                { planet: 'Júpiter_Rojo', color: 'pink' },
                { planet: 'Marte_Rojo', color: 'pink' }
            ],
            3: [  // Jugador 4 (Amarillo)
                { planet: 'Mercurio_Amarillo', color: 'yellow' },
                { planet: 'Venus_Amarillo', color: 'yellow' }
            ]
        };

        // Estado del juego
        const gameState = {
            currentPlayer: 0,
            players: [],
            pieces: [],
            board: [],
            diceResult: null,
            selectedPiece: null,
            possibleMoves: [],
            selectionMode: false,
            gameOver: false,
            gameMode: 2, // Por defecto 2 jugadores
            humanPlayers: [0], // Por defecto, solo el jugador 1 (Verde) es humano
            activePlayerIndices: [], // Los jugadores activos en la partida
            houseSelected: false // Indica si se ha seleccionado una casa para sacar ficha
        };
        
        // Inicializar el tablero con todas las casillas y símbolos
        function initializeBoard() {
            const board = document.getElementById('board');
            
            // Limpiar el tablero
            board.innerHTML = '';
            gameState.board = [];
            
            // Tablero 15x15
            const size = 15;

            // Debug inicio
            debug("Inicializando tablero");
            
            // Crear el tablero base
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Posiciones de Saturno en la cruz
                    const isSaturnCrossPosition = 
                        (row === 0 && col === 7) || // Arriba
                        (row === 7 && col === 0) || // Izquierda
                        (row === 7 && col === 14) || // Derecha
                        (row === 14 && col === 7); // Abajo
                        
                    // Verificar si esta celda es una posición de Saturno (fondo azul oscuro)
                    const isSaturnPosition = saturnPositions.some(
                        pos => pos.row === row && pos.col === col
                    );
                    
                    // Inicialmente todas las celdas tienen borde a menos que se indique lo contrario
                    let cellHasContent = false;
                    
                    // Verificar si la celda está en alguna de las casas
                    let inHouse = false;
                    let houseIndex = -1;
                    
                    for (let i = 0; i < houseZones.length; i++) {
                        const house = houseZones[i];
                        if (row >= house.startRow && row < house.startRow + house.size && 
                            col >= house.startCol && col < house.startCol + house.size) {
                            inHouse = true;
                            houseIndex = i;
                            break;
                        }
                    }
                    
                    // Verificar si la celda pertenece a una línea específica
                    let lineName = null;
                    for (const [name, line] of Object.entries(boardLines)) {
                        if ((line.type === "horizontal" && row === line.row && col >= line.minCol && col <= line.maxCol) ||
                            (line.type === "vertical" && col === line.col && row >= line.minRow && row <= line.maxRow)) {
                            lineName = name;
                            cell.classList.add('line-highlight');
                            cell.dataset.line = name;
                            break;
                        }
                    }
                    
                    // Comprobamos si la celda es parte de la cruz
                    let isCellInCross = false;
                    let cellCrossColor = null;
                    
                    // Cruz horizontal - EXCLUIR posiciones extremas (0,7) y (14,7)
                    if (row === 7 && col !== 7 && col !== 0 && col !== 14) {
                        isCellInCross = true;
                        if (col < 7) {
                            cell.style.backgroundColor = '#ffde00'; // Amarillo
                            cellCrossColor = 'yellow';
                        } else {
                            cell.style.backgroundColor = '#1aa3ff'; // Azul
                            cellCrossColor = 'blue';
                        }
                        cellHasContent = true;
                    }

                    // Cruz vertical - EXCLUIR posiciones extremas (7,0) y (7,14)
                    else if (col === 7 && row !== 7 && row !== 0 && row !== 14) {
                        isCellInCross = true;
                        if (row < 7) {
                            cell.style.backgroundColor = '#ff1493'; // Rosa
                            cellCrossColor = 'pink';
                        } else {
                            cell.style.backgroundColor = '#00b050'; // Verde
                            cellCrossColor = 'green';
                        }
                        cellHasContent = true;
                    }
                    
                    // Centro con SVG personalizado de Corel Draw
                    else if (row === 7 && col === 7) {
                        cell.style.backgroundColor = '#2a2a8c'; // Azul oscuro
                        
                        // Crear el contenedor del SVG
                        const svgContainer = document.createElement('div');
                        svgContainer.className = 'center-container';
                        
                        // Contenido SVG de la estrella de 8 puntas (ajustado para visualización)
                        const svgContent = `
                            <svg xmlns="http://www.w3.org/2000/svg" xml:space="preserve" 
                                 width="90%" height="90%" viewBox="545.87 8701.18 6775.3 6775.3"
                                 style="shape-rendering:geometricPrecision; text-rendering:geometricPrecision; 
                                       image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd">
                              <polygon fill="white" stroke="none" 
                                       points="3933.52,8701.18 4496.45,10729.81 6328.95,9693.4 5292.54,11525.9 
                                              7321.17,12088.83 5292.54,12651.76 6328.95,14484.26 4496.45,13447.85 
                                              3933.52,15476.48 3370.59,13447.85 1538.09,14484.26 2574.5,12651.76 
                                              545.87,12088.83 2574.5,11525.9 1538.09,9693.4 3370.59,10729.81" />
                            </svg>
                        `;
                        
                        // Añadir el SVG al contenedor
                        svgContainer.innerHTML = svgContent;
                        cell.appendChild(svgContainer);
                        
                        cellHasContent = true;
                    }
                    // Posición de Saturno
                    else if (isSaturnPosition || isSaturnCrossPosition) {
                        cell.classList.add('saturn-cell');
                        cell.style.backgroundColor = '#000088'; // Azul oscuro
                        cellHasContent = true;
                    }
                    // Casillas sin contenido y fuera de zonas de casa
                    else if (!inHouse) {
                        cell.classList.add('no-border');
                    }
                    
                    board.appendChild(cell);
                    
                    // Guardar referencia en el estado del juego
                    gameState.board.push({
                        row,
                        col,
                        hasSymbol: false,
                        symbol: null,
                        symbolColor: null,
                        pieces: [],
                        inHouse: inHouse,
                        houseIndex: houseIndex,
                        isSaturnPosition: isSaturnPosition || isSaturnCrossPosition,
                        isInCross: isCellInCross,
                        crossColor: cellCrossColor,
                        lineName: lineName
                    });
                    
                    // Evento de clic para mover fichas
                    cell.addEventListener('click', () => handleCellClick(row, col));
                }
            }
            
            // Añadir los overlays de las casas
            for (const house of houseZones) {
                const houseOverlay = document.createElement('div');
                houseOverlay.className = 'house-overlay';
                houseOverlay.style.width = `${house.size * (100/15)}%`;
                houseOverlay.style.height = `${house.size * (100/15)}%`;
                houseOverlay.style.left = `${house.startCol * (100/15)}%`;
                houseOverlay.style.top = `${house.startRow * (100/15)}%`;
                houseOverlay.style.backgroundColor = house.color;
                
                // Añadir el símbolo de la casa en el centro
                const symbolDiv = document.createElement('div');
                symbolDiv.className = `house-symbol ${house.symbol}-symbol`;
                symbolDiv.style.backgroundColor = house.color;
                
                // Añadir atributo para identificar a qué jugador pertenece esta casa
                let playerIndex = -1;
                if (house.name === "green") playerIndex = 0;
                else if (house.name === "blue") playerIndex = 1;
                else if (house.name === "pink") playerIndex = 2;
                else if (house.name === "yellow") playerIndex = 3;
                
                symbolDiv.dataset.house = playerIndex.toString();
                
                // Añadir evento de clic para seleccionar ficha de casa
                symbolDiv.addEventListener('click', () => handleHouseSymbolClick(playerIndex));
                
                houseOverlay.appendChild(symbolDiv);
                board.appendChild(houseOverlay);
            }
            
            // DEFINICIÓN EXPLÍCITA DE CADA SÍMBOLO
            const symbolsMap = [
                // FILA 0
                { row: 0, col: 6, planet: 'Júpiter_Azul', color: 'blue' },
                { row: 0, col: 7, planet: 'Saturno', color: 'white' },
                { row: 0, col: 8, planet: 'Luna_Amarillo', color: 'yellow' },
                
                // FILA 1
                { row: 1, col: 6, planet: 'Marte_Rojo', color: 'pink' },
                { row: 1, col: 7, planet: 'Júpiter', color: 'white' },
                { row: 1, col: 8, planet: 'Sol_Verde', color: 'green' },
                
                // FILA 2
                { row: 2, col: 6, planet: 'Venus_Verde', color: 'green' },
                { row: 2, col: 7, planet: 'Marte', color: 'white' },
                { row: 2, col: 8, planet: 'Júpiter_Rojo', color: 'pink' },
                
                // FILA 3
                { row: 3, col: 6, planet: 'Mercurio_Amarillo', color: 'yellow' },
                { row: 3, col: 7, planet: 'Venus', color: 'white' },
                { row: 3, col: 8, planet: 'Marte_Azul', color: 'blue' },
                
                // FILA 4
                { row: 4, col: 6, planet: 'Luna_Azul', color: 'blue' },
                { row: 4, col: 7, planet: 'Mercurio', color: 'white' },
                { row: 4, col: 8, planet: 'Venus_Amarillo', color: 'yellow' },
                
                // FILA 5
                { row: 5, col: 6, planet: 'Sol_Rojo', color: 'pink' },
                { row: 5, col: 7, planet: 'Luna', color: 'white' },
                { row: 5, col: 8, planet: 'Mercurio_Verde', color: 'green' },
                
                // FILA 6
                { row: 6, col: 0, planet: 'Luna_Amarillo', color: 'yellow' },
                { row: 6, col: 1, planet: 'Sol_Verde', color: 'green' },
                { row: 6, col: 2, planet: 'Júpiter_Rojo', color: 'pink' },
                { row: 6, col: 3, planet: 'Marte_Azul', color: 'blue' },
                { row: 6, col: 4, planet: 'Venus_Amarillo', color: 'yellow' },
                { row: 6, col: 5, planet: 'Mercurio_Verde', color: 'green' },
                { row: 6, col: 6, planet: 'Saturno', color: 'white' },
                { row: 6, col: 7, planet: 'Sol', color: 'white' },
                { row: 6, col: 8, planet: 'Saturno', color: 'white' },
                { row: 6, col: 9, planet: 'Sol_Rojo', color: 'pink' },
                { row: 6, col: 10, planet: 'Luna_Azul', color: 'blue' },
                { row: 6, col: 11, planet: 'Mercurio_Amarillo', color: 'yellow' },
                { row: 6, col: 12, planet: 'Venus_Verde', color: 'green' },
                { row: 6, col: 13, planet: 'Marte_Rojo', color: 'pink' },
                { row: 6, col: 14, planet: 'Júpiter_Azul', color: 'blue' },
                
                // FILA 7 - CRUZ HORIZONTAL
                { row: 7, col: 0, planet: 'Saturno', color: 'white' },
                { row: 7, col: 1, planet: 'Júpiter', color: 'white' },
                { row: 7, col: 2, planet: 'Marte', color: 'white' },
                { row: 7, col: 3, planet: 'Venus', color: 'white' },
                { row: 7, col: 4, planet: 'Mercurio', color: 'white' },
                { row: 7, col: 5, planet: 'Luna', color: 'white' },
                { row: 7, col: 6, planet: 'Sol', color: 'white' },
                { row: 7, col: 8, planet: 'Sol', color: 'white' },
                { row: 7, col: 9, planet: 'Luna', color: 'white' },
                { row: 7, col: 10, planet: 'Mercurio', color: 'white' },
                { row: 7, col: 11, planet: 'Venus', color: 'white' },
                { row: 7, col: 12, planet: 'Marte', color: 'white' },
                { row: 7, col: 13, planet: 'Júpiter', color: 'white' },
                { row: 7, col: 14, planet: 'Saturno', color: 'white' },
                
                // FILA 8
                { row: 8, col: 0, planet: 'Júpiter_Azul', color: 'blue' },
                { row: 8, col: 1, planet: 'Marte_Rojo', color: 'pink' },
                { row: 8, col: 2, planet: 'Venus_Verde', color: 'green' },
                { row: 8, col: 3, planet: 'Mercurio_Amarillo', color: 'yellow' },
                { row: 8, col: 4, planet: 'Luna_Azul', color: 'blue' },
                { row: 8, col: 5, planet: 'Sol_Rojo', color: 'pink' },
                { row: 8, col: 6, planet: 'Saturno', color: 'white' },
                { row: 8, col: 7, planet: 'Sol', color: 'white' },
                { row: 8, col: 8, planet: 'Saturno', color: 'white' },
                { row: 8, col: 9, planet: 'Mercurio_Verde', color: 'green' },
                { row: 8, col: 10, planet: 'Venus_Amarillo', color: 'yellow' },
                { row: 8, col: 11, planet: 'Marte_Azul', color: 'blue' },
                { row: 8, col: 12, planet: 'Júpiter_Rojo', color: 'pink' },
                { row: 8, col: 13, planet: 'Sol_Verde', color: 'green' },
                { row: 8, col: 14, planet: 'Luna_Amarillo', color: 'yellow' },
                
                // FILA 9
                { row: 9, col: 6, planet: 'Mercurio_Verde', color: 'green' },
                { row: 9, col: 7, planet: 'Luna', color: 'white' },
                { row: 9, col: 8, planet: 'Sol_Rojo', color: 'pink' },
                
                // FILA 10
                { row: 10, col: 6, planet: 'Venus_Amarillo', color: 'yellow' },
                { row: 10, col: 7, planet: 'Mercurio', color: 'white' },
                { row: 10, col: 8, planet: 'Luna_Azul', color: 'blue' },
                
                // FILA 11
                { row: 11, col: 6, planet: 'Marte_Azul', color: 'blue' },
                { row: 11, col: 7, planet: 'Venus', color: 'white' },
                { row: 11, col: 8, planet: 'Mercurio_Amarillo', color: 'yellow' },
                
                // FILA 12
                { row: 12, col: 6, planet: 'Júpiter_Rojo', color: 'pink' },
                { row: 12, col: 7, planet: 'Marte', color: 'white' },
                { row: 12, col: 8, planet: 'Venus_Verde', color: 'green' },
                
                // FILA 13
                { row: 13, col: 6, planet: 'Sol_Verde', color: 'green' },
                { row: 13, col: 7, planet: 'Júpiter', color: 'white' },
                { row: 13, col: 8, planet: 'Marte_Rojo', color: 'pink' },
                
                // FILA 14
                { row: 14, col: 6, planet: 'Luna_Amarillo', color: 'yellow' },
                { row: 14, col: 7, planet: 'Saturno', color: 'white' },
                { row: 14, col: 8, planet: 'Júpiter_Azul', color: 'blue' }
            ];
            
            // Añadir todos los símbolos al tablero según la configuración
            for (const symbolInfo of symbolsMap) {
                // Para las celdas que están en zonas de casa, no añadimos símbolos
                const isInHouseZone = houseZones.some(house => 
                    symbolInfo.row >= house.startRow && 
                    symbolInfo.row < house.startRow + house.size && 
                    symbolInfo.col >= house.startCol && 
                    symbolInfo.col < house.startCol + house.size
                );
                
                if (!isInHouseZone) {
                    const cells = document.querySelectorAll(`.cell[data-row="${symbolInfo.row}"][data-col="${symbolInfo.col}"]`);
                    
                    if (cells.length > 0) {
                        const cell = cells[0];
                        
                        // Crear el círculo con el símbolo
                        const symbolDiv = document.createElement('div');
                        symbolDiv.className = `symbol circle-${symbolInfo.color}`;
                        
                        // Obtener el símbolo Unicode para el planeta
                        const symbolObj = symbols.find(s => s.name === symbolInfo.planet);
                        const symbolChar = symbolObj ? symbolObj.symbol : '?';
                        
                        // Añadir el símbolo
                        symbolDiv.textContent = symbolChar;
                        
                        // Añadir el círculo a la celda
                        cell.appendChild(symbolDiv);
                        
                        // Remover la clase no-border si tiene un símbolo
                        cell.classList.remove('no-border');
                        
                        // Actualizar el estado del juego
                        const cellIndex = gameState.board.findIndex(c => c.row === symbolInfo.row && c.col === symbolInfo.col);
                        if (cellIndex !== -1) {
                            gameState.board[cellIndex].hasSymbol = true;
                            gameState.board[cellIndex].symbol = symbolInfo.planet;
                            gameState.board[cellIndex].planet = symbolInfo.planet;
                            gameState.board[cellIndex].symbolColor = symbolInfo.color;
                        }
                    }
                }
            }
            
            // Inicializar las casas de los jugadores
            gameState.houses = [
                { row: 12, col: 12 }, // Jugador 1 (Verde)
                { row: 2, col: 12 },  // Jugador 2 (Azul)
                { row: 2, col: 2 },   // Jugador 3 (Rosa)
                { row: 12, col: 2 }   // Jugador 4 (Amarillo)
            ];

            // Añadir información sobre las zonas de cruz
            addCrossInformation();

            // Debug fin
            debug("Tablero inicializado correctamente");
        }
        
        // Añadir información de la zona de cruz a las celdas del tablero
        function addCrossInformation() {
            // Actualizar la información de las celdas del tablero con las zonas de cruz específicas
            for (let i = 0; i < gameState.board.length; i++) {
                const cell = gameState.board[i];
                
                // Para cada jugador, verificar si la celda está en su zona de cruz
                for (let playerIdx = 0; playerIdx < 4; playerIdx++) {
                    const zone = playerCrossZones[playerIdx];
                    
                    if (zone.type === "vertical" && cell.col === zone.col && 
                        cell.row >= zone.minRow && cell.row <= zone.maxRow) {
                        cell.isInCross = true;
                        cell.crossColor = zone.color;
                        cell.inPlayerCross = playerIdx;
                    } 
                    else if (zone.type === "horizontal" && cell.row === zone.row && 
                        cell.col >= zone.minCol && cell.col <= zone.maxCol) {
                        cell.isInCross = true;
                        cell.crossColor = zone.color;
                        cell.inPlayerCross = playerIdx;
                    }
                }
            }
        }
        
        // Inicializar la interfaz de jugadores
        function initializePlayerInfo() {
            const gameInfoDiv = document.getElementById('game-info');
            gameInfoDiv.innerHTML = '';
            
            // Para cada jugador activo, crear su panel de información
            for (const index of gameState.activePlayerIndices) {
                const player = gameState.players[index];
                const bgColor = player.bgColor || 'transparent';
                
                const playerDiv = document.createElement('div');
                playerDiv.className = `player-info ${index === gameState.currentPlayer ? 'active' : ''}`;
                playerDiv.style.backgroundColor = bgColor;
                playerDiv.style.width = gameState.gameMode === 2 ? '48%' : '23%';
                
                const playerNameSpan = document.createElement('h3');
                playerNameSpan.textContent = `${player.name} (${player.colorName})`;
                
                const housesDiv = document.createElement('div');
                housesDiv.className = 'houses';
                
                // Añadir fichas en casa
                for (let i = 0; i < player.piecesInHouse; i++) {
                    const housePiece = document.createElement('div');
                    housePiece.className = `house-piece ${player.color}`;
                    housesDiv.appendChild(housePiece);
                }
                
                playerDiv.appendChild(playerNameSpan);
                playerDiv.appendChild(housesDiv);
                gameInfoDiv.appendChild(playerDiv);
            }
        }
        
        // Tirar el dado con símbolos astrológicos
        function rollDice() {
            debug("Tirando dado...");
            
            // Limpiar cualquier selección previa
            if (gameState.selectedPiece) {
                const pieceElement = document.getElementById(gameState.selectedPiece.id);
                if (pieceElement) {
                    pieceElement.classList.remove('selected-piece');
                }
            }
            gameState.selectedPiece = null;
            gameState.selectionMode = false;
            
            const diceResult = document.getElementById('dice-result');
            const elementInfo = document.getElementById('element-info');
            
            // Elegir resultado aleatorio de las 12 combinaciones posibles
            const randomIndex = Math.floor(Math.random() * dadoCombinations.length);
            const result = dadoCombinations[randomIndex];
            
            // Obtener el símbolo Unicode para el planeta
            const symbolObj = symbols.find(s => s.name === result.planet);
            const symbolChar = symbolObj ? symbolObj.symbol : '?';
            
            // Mostrar el resultado en el dado
            diceResult.textContent = symbolChar;
            diceResult.className = 'dice-result';
            diceResult.classList.add(`circle-${result.color}`);
            
            // Mostrar información del elemento
            elementInfo.textContent = `${result.planet} - ${result.element}`;
            
            // MAPEO CORRECTO DEL ELEMENTO AL COLOR DEL TABLERO
            const boardColor = mapElementToColor(result.element);
            
            // Actualizar estado del juego
            gameState.diceResult = {
                planet: result.planet,
                element: result.element,
                color: result.color,
                boardColor: boardColor
            };
            
            // Limpiar resaltado previo
            clearHighlights();
            
            // Encontrar movimientos posibles con las nuevas reglas
            findPossibleMoves();
            
            // Actualizar controles basado en si hay movimientos posibles
            document.getElementById('roll-dice').disabled = true;
            
            if (gameState.possibleMoves.length === 0) {
                document.getElementById('move-piece').disabled = true;
                document.getElementById('skip-turn').disabled = false; // Puede pasar turno si no hay movimientos
                
                logMessage(`${gameState.players[gameState.activePlayerIndices[gameState.currentPlayer]].name} ha tirado el dado: ${result.planet} - ${result.element} (${boardColor}).`);
                logMessage("No hay movimientos posibles. Puedes pasar turno.");
            } else {
                document.getElementById('move-piece').disabled = false;
                document.getElementById('skip-turn').disabled = true; // No puede pasar turno si hay movimientos
                
                // Resaltar los movimientos posibles
                highlightPossibleMoves();
                
                // Log para el jugador mostrando el color específico
                logMessage(`${gameState.players[gameState.activePlayerIndices[gameState.currentPlayer]].name} ha tirado el dado: ${result.planet} - ${result.element} (${boardColor}).`);
                
                const fromHouseMoves = gameState.possibleMoves.filter(m => m.type === 'fromHouse').length;
                const normalMoves = gameState.possibleMoves.filter(m => m.type === 'normal').length;
                
                if (fromHouseMoves > 0 && normalMoves === 0) {
                    logMessage(`Hay ${fromHouseMoves} posibilidades para sacar fichas de casa.`);
                } else if (fromHouseMoves === 0 && normalMoves > 0) {
                    logMessage(`Hay ${normalMoves} movimientos posibles. Haz clic en "Mover Ficha" para seleccionar una.`);
                } else {
                    logMessage(`Hay ${gameState.possibleMoves.length} movimientos posibles (${fromHouseMoves} desde casa, ${normalMoves} en tablero).`);
                }
            }
            
            // Si es IA, hacer su movimiento automáticamente
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            if (gameState.players[currentPlayerIdx].ai && !gameState.gameOver) {
                setTimeout(playAITurn, 1000);
            }
        }
        
        // Mapear elemento a color
        function mapElementToColor(element) {
            switch (element) {
                case 'Fuego': return 'red'; // Cambiado a 'red' para coincidir con el color en el tablero
                case 'Agua': return 'blue';
                case 'Tierra': return 'green';
                case 'Aire': return 'yellow';
                default: return 'white';
            }
        }
        
        function clearHighlights() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('highlight-move');
            });
            
            // También limpiar cualquier resaltado de ficha seleccionada
            const pieces = document.querySelectorAll('.piece');
            pieces.forEach(piece => {
                piece.classList.remove('selected-piece');
            });
            
            // Limpiar selección de casa
            const selectedHouse = document.querySelector('.selected-house');
            if (selectedHouse) {
                selectedHouse.classList.remove('selected-house');
            }
            
            // Resetear modo de casa seleccionada
            gameState.houseSelected = false;
        }
        
        // Resaltar los movimientos posibles
        function highlightPossibleMoves() {
            // Primero limpiamos cualquier resaltado anterior
            clearHighlights();
            
            debug(`Resaltando ${gameState.possibleMoves.length} movimientos posibles`);
            
            // Primero confirmar que hay movimientos posibles
            if (gameState.possibleMoves.length === 0) {
                return;
            }
            
            // Verificar que no estemos resaltando movimientos a la cruz inadecuados
            for (const move of gameState.possibleMoves) {
                const targetCell = gameState.board.find(c => c.row === move.targetRow && c.col === move.targetCol);
                
                // Si es un movimiento a la cruz, verificar que sea válido
                if (targetCell && targetCell.isInCross) {
                    // Si no es un movimiento explícitamente marcado como movimiento a cruz, ignorarlo
                    if (!move.isCrossMove) {
                        debug(`ADVERTENCIA: Ignorando movimiento a cruz no válido: (${move.targetRow}, ${move.targetCol})`);
                        continue;
                    }
                    
                    // Verificar que el planeta coincida con la posición
                    const expectedPosition = findCrossPlanetPosition(move.crossPlanet, 
                                                gameState.activePlayerIndices[gameState.currentPlayer]);
                    
                    if (!expectedPosition || expectedPosition.row !== move.targetRow || expectedPosition.col !== move.targetCol) {
                        debug(`ADVERTENCIA: Ignorando movimiento a cruz con planeta incorrecto: (${move.targetRow}, ${move.targetCol})`);
                        continue;
                    }
                }
                
                // Resaltar el movimiento válido
                const cell = document.querySelector(`.cell[data-row="${move.targetRow}"][data-col="${move.targetCol}"]`);
                if (cell) {
                    cell.classList.add('highlight-move');
                }
            }
        }
        
        // Determinar la línea a la que pertenece una celda
        function getLineName(row, col) {
            for (const [name, line] of Object.entries(boardLines)) {
                if ((line.type === "horizontal" && row === line.row && col >= line.minCol && col <= line.maxCol) ||
                    (line.type === "vertical" && col === line.col && row >= line.minRow && row <= line.maxRow)) {
                    return name;
                }
            }
            return null;
        }
        
        // Verificar si dos líneas son adyacentes o la misma
function areLinesConnected(line1, line2) {
    // Si es la misma línea, están conectadas
    if (line1 === line2) {
        debug(`Las líneas ${line1} y ${line2} son la misma línea`);
        return true;
    }
    
    if (!line1 || !line2) return false;
    
    // Verificar si las líneas son adyacentes según la definición explícita
    if (adjacentLines[line1] && adjacentLines[line1].includes(line2)) {
        debug(`Las líneas ${line1} y ${line2} son adyacentes según la definición de adjacentLines`);
        
        // Ahora, las líneas son adyacentes pero necesitamos aplicar la única restricción específica:
        // Si una ficha está en la línea húmeda de su casa, no puede moverse a la línea seca de la casa anterior
        
        // Obtener información de las líneas
        const getLineInfo = (line) => {
            const color = line.includes("Rojo") ? "Rojo" : 
                         line.includes("Amarillo") ? "Amarillo" : 
                         line.includes("Verde") ? "Verde" : 
                         line.includes("Azul") ? "Azul" : "";
                         
            const type = line.includes("Humedo") ? "Humedo" : "Seco";
            
            return { color, type };
        };
        
        const line1Info = getLineInfo(line1);
        const line2Info = getLineInfo(line2);
        
        // Obtener el jugador actual
        const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
        
        // Mapeo de jugadores a sus colores
        const playerColors = {
            0: "Verde",     // Jugador Verde
            1: "Azul",      // Jugador Azul
            2: "Rojo",      // Jugador Rosa (Rojo)
            3: "Amarillo"   // Jugador Amarillo
        };
        
        // Mapeo de casas anteriores para cada jugador
        const previousColors = {
            "Verde": "Amarillo",
            "Azul": "Verde",
            "Rojo": "Azul",
            "Amarillo": "Rojo"
        };
        
        // Obtener el color del jugador actual
        const playerColor = playerColors[currentPlayerIdx];
        // Obtener el color de la casa anterior
        const previousColor = previousColors[playerColor];
        
        // ÚNICA RESTRICCIÓN: Si una ficha está en la línea húmeda de su casa, no puede moverse a la línea seca de la casa anterior
        if (line1Info.color === playerColor && line1Info.type === "Humedo" && 
            line2Info.color === previousColor && line2Info.type === "Seco") {
            debug(`RESTRICCIÓN: Jugador ${currentPlayerIdx} (${playerColor}) no puede mover de su línea Húmeda (${line1}) a línea Seca de casa anterior (${line2})`);
            return false; // No están conectadas para este movimiento específico
        }
        
        // Para todos los demás casos, las líneas están conectadas
        return true;
    }
    
    // Si no están en la definición explícita de adyacencias, no están conectadas
    debug(`Las líneas ${line1} y ${line2} NO están conectadas según adjacentLines`);
    return false;
}
        
        // Verificar si una posición está lista para entrar a la cruz
        function isPositionReadyForCross(row, col, playerIdx) {
            const playerZone = playerCrossZones[playerIdx];
            
            debug(`Verificando si (${row}, ${col}) está listo para cruz de jugador ${playerIdx}`);
            
            // Primero verificar si la celda está en una línea definida
            // (no debe estar en casa o en áreas indefinidas)
            const cell = gameState.board.find(c => c.row === row && c.col === col);
            if (!cell || !cell.lineName) {
                debug(`La celda no está en una línea definida`);
                return false;
            }
            
            // Para zonas verticales (Verde y Rosa)
            if (playerZone.type === "vertical") {
                // Verde: verificar si está en columna 8 (a la derecha de la cruz vertical) 
                // o columna 6 (a la izquierda de la cruz vertical)
                // y dentro del rango de filas de la cruz
                // Y además verificar que no está en una línea de casa inicial
                if (playerIdx === 0) {
                    const startLines = playerStartLines[playerIdx];
                    const isInStartLine = startLines.includes(cell.lineName);
                    
                    // Si está en línea inicial, no está lista para entrar a la cruz
                    if (isInStartLine) {
                        debug(`Verde: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                        return false;
                    }
                    
                    const isReady = (col === 8 || col === 6) && row >= playerZone.minRow && row <= playerZone.maxRow;
                    debug(`Verde: (${row}, ${col}) está en posición: ${isReady}`);
                    return isReady;
                }
                // Rosa: verificar si está en columna 6 (a la izquierda de la cruz vertical)
                // o columna 8 (a la derecha de la cruz vertical)
                // y dentro del rango de filas de la cruz
                else if (playerIdx === 2) {
                    const startLines = playerStartLines[playerIdx];
                    const isInStartLine = startLines.includes(cell.lineName);
                    
                    // Si está en línea inicial, no está lista para entrar a la cruz
                    if (isInStartLine) {
                        debug(`Rosa: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                        return false;
                    }
                    
                    const isReady = (col === 6 || col === 8) && row >= playerZone.minRow && row <= playerZone.maxRow;
                    debug(`Rosa: (${row}, ${col}) está en posición: ${isReady}`);
                    return isReady;
                }
            }
            // Para zonas horizontales (Azul y Amarillo)
            else {
                // Azul: verificar si está en fila 6 (arriba de la cruz horizontal)
                // o fila 8 (abajo de la cruz horizontal)
                // y dentro del rango de columnas de la cruz
                if (playerIdx === 1) {
                    const startLines = playerStartLines[playerIdx];
                    const isInStartLine = startLines.includes(cell.lineName);
                    
                    // Si está en línea inicial, no está lista para entrar a la cruz
                    if (isInStartLine) {
                        debug(`Azul: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                        return false;
                    }
                    
                    const isReady = (row === 6 || row === 8) && col >= playerZone.minCol && col <= playerZone.maxCol;
                    debug(`Azul: (${row}, ${col}) está en posición: ${isReady}`);
                    return isReady;
                }
                // Amarillo: verificar si está en fila 8 (abajo de la cruz horizontal)
                // o fila 6 (arriba de la cruz horizontal)
                // y dentro del rango de columnas de la cruz
                else if (playerIdx === 3) {
                    const startLines = playerStartLines[playerIdx];
                    const isInStartLine = startLines.includes(cell.lineName);
                    
                    // Si está en línea inicial, no está lista para entrar a la cruz
                    if (isInStartLine) {
                        debug(`Amarillo: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                        return false;
                    }
                    
                    const isReady = (row === 8 || row === 6) && col >= playerZone.minCol && col <= playerZone.maxCol;
                    debug(`Amarillo: (${row}, ${col}) está en posición: ${isReady}`);
                    return isReady;
                }
            }
            
            debug(`No está en posición de cruz para jugador ${playerIdx}`);
            return false;
        }
        
// Corrección para la función isPositionReadyForCross
// Esta función verifica si una ficha está en posición para entrar a la cruz

function isPositionReadyForCross(row, col, playerIdx) {
    const playerZone = playerCrossZones[playerIdx];
    
    debug(`Verificando si (${row}, ${col}) está listo para cruz de jugador ${playerIdx}`);
    
    // Primero verificar si la celda está en una línea definida
    const cell = gameState.board.find(c => c.row === row && c.col === col);
    if (!cell || !cell.lineName) {
        debug(`La celda no está en una línea definida`);
        return false;
    }
    
    // Para zonas verticales (Verde y Rosa)
    if (playerZone.type === "vertical") {
        // Verde: verificar si está en columna 8 (a la derecha de la cruz vertical) 
        // o columna 6 (a la izquierda de la cruz vertical)
        // y dentro del rango de filas de la cruz o en la fila límite
        if (playerIdx === 0) {
            const startLines = playerStartLines[playerIdx];
            const isInStartLine = startLines.includes(cell.lineName);
            
            // Si está en línea inicial, no está lista para entrar a la cruz
            if (isInStartLine) {
                debug(`Verde: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                return false;
            }
            
            // Incluir explícitamente las posiciones límite (filas 8 y 9)
            const isReady = (
                (col === 8 || col === 6) && 
                ((row >= playerZone.minRow && row <= playerZone.maxRow) || 
                 // Posiciones especiales para el límite
                 (col === 6 && row === 8) || 
                 (col === 8 && row === 8))
            );
            debug(`Verde: (${row}, ${col}) está en posición: ${isReady}`);
            return isReady;
        }
        // Rosa: verificar posiciones similares pero en su zona
        else if (playerIdx === 2) {
            const startLines = playerStartLines[playerIdx];
            const isInStartLine = startLines.includes(cell.lineName);
            
            if (isInStartLine) {
                debug(`Rosa: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                return false;
            }
            
            // Incluir explícitamente las posiciones límite (filas 6 y 7)
            const isReady = (
                (col === 6 || col === 8) && 
                ((row >= playerZone.minRow && row <= playerZone.maxRow) || 
                 // Posiciones especiales para el límite
                 (col === 6 && row === 6) || 
                 (col === 8 && row === 6))
            );
            debug(`Rosa: (${row}, ${col}) está en posición: ${isReady}`);
            return isReady;
        }
    }
    // Para zonas horizontales (Azul y Amarillo)
    else {
        // Azul: verificar posiciones para su zona
        if (playerIdx === 1) {
            const startLines = playerStartLines[playerIdx];
            const isInStartLine = startLines.includes(cell.lineName);
            
            if (isInStartLine) {
                debug(`Azul: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                return false;
            }
            
            // Incluir explícitamente las posiciones límite (columnas 8 y 9)
            const isReady = (
                (row === 6 || row === 8) && 
                ((col >= playerZone.minCol && col <= playerZone.maxCol) || 
                 // Posiciones especiales para el límite
                 (row === 6 && col === 8) || 
                 (row === 8 && col === 8))
            );
            debug(`Azul: (${row}, ${col}) está en posición: ${isReady}`);
            return isReady;
        }
        // Amarillo: verificar posiciones para su zona
        else if (playerIdx === 3) {
            const startLines = playerStartLines[playerIdx];
            const isInStartLine = startLines.includes(cell.lineName);
            
            if (isInStartLine) {
                debug(`Amarillo: (${row}, ${col}) está en línea inicial, NO está en posición para cruz`);
                return false;
            }
            
            // Incluir explícitamente las posiciones límite (columnas 6 y 7)
            const isReady = (
                (row === 8 || row === 6) && 
                ((col >= playerZone.minCol && col <= playerZone.maxCol) || 
                 // Posiciones especiales para el límite
                 (row === 8 && col === 6) || 
                 (row === 6 && col === 6))
            );
            debug(`Amarillo: (${row}, ${col}) está en posición: ${isReady}`);
            return isReady;
        }
    }
    
    debug(`No está en posición de cruz para jugador ${playerIdx}`);
    return false;
}

// Corrección para la función findPossibleMoves
// Esta función determina qué movimientos son posibles en base a la tirada del dado

function findPossibleMoves() {
    gameState.possibleMoves = [];
    
    if (!gameState.diceResult) return;
    
    const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
    const currentPlayer = gameState.players[currentPlayerIdx];
    const { planet, boardColor } = gameState.diceResult;
    
    debug(`Buscando movimientos para planeta: ${planet}, color: ${boardColor}`);
    
    // 1. Verificar si hay fichas en posición para entrar a la cruz
    // SOLO cuando la tirada coincide con el planeta específico (ignorando el color)
    const basePlanet = planet.split('_')[0];
    
    // Planetas válidos para la cruz
    const validPlanets = ["Sol", "Luna", "Mercurio", "Venus", "Marte", "Júpiter"];
    
    // Antes de buscar, mostrar información de depuración sobre todas las fichas del jugador actual
    const playerPieces = gameState.pieces.filter(p => p.player === currentPlayerIdx && !p.inCross);
    debug(`El jugador ${currentPlayerIdx} tiene ${playerPieces.length} fichas en el tablero`);
    
    for (const piece of playerPieces) {
        const ready = isPositionReadyForCross(piece.row, piece.col, currentPlayerIdx);
        debug(`Ficha en (${piece.row}, ${piece.col}): ¿Lista para cruz? ${ready}`);
    }
    
    if (validPlanets.includes(basePlanet)) {
        debug(`Planeta base válido para la cruz: ${basePlanet}`);
        
        // Encontrar la posición esperada en la cruz para este planeta
        const expectedCrossPosition = findCrossPlanetPosition(basePlanet, currentPlayerIdx);
        if (expectedCrossPosition) {
            debug(`Posición esperada en cruz para ${basePlanet}: (${expectedCrossPosition.row}, ${expectedCrossPosition.col})`);
        } else {
            debug(`No se encontró posición en cruz para ${basePlanet}`);
        }
        
        // Buscar fichas que estén en posición para entrar a la cruz
        const piecesReadyForCross = playerPieces.filter(p => 
            isPositionReadyForCross(p.row, p.col, currentPlayerIdx)
        );
        
        if (piecesReadyForCross.length > 0) {
            debug(`Encontradas ${piecesReadyForCross.length} fichas en posición para entrar a la cruz`);
            
            // Para cada ficha lista, verificar si puede entrar a la cruz con este planeta
            for (const piece of piecesReadyForCross) {
                const crossPosition = findCrossPlanetPosition(basePlanet, currentPlayerIdx);
                
                if (crossPosition) {
                    debug(`Ficha en (${piece.row}, ${piece.col}) puede entrar a la cruz en (${crossPosition.row}, ${crossPosition.col})`);
                    
                    // Verificar que no hay otra ficha propia en esa posición
                    const isOccupiedBySamePlayer = gameState.pieces.some(p => 
                        p.player === currentPlayerIdx && 
                        p.row === crossPosition.row && 
                        p.col === crossPosition.col);
                    
                    if (!isOccupiedBySamePlayer) {
                        gameState.possibleMoves.push({
                            type: 'normal',
                            pieceId: piece.id,
                            currentRow: piece.row,
                            currentCol: piece.col,
                            targetRow: crossPosition.row,
                            targetCol: crossPosition.col,
                            isCrossMove: true,
                            crossPlanet: basePlanet // Añadir el planeta para verificación posterior
                        });
                        debug(`Añadido movimiento a cruz para planeta ${basePlanet} en (${crossPosition.row}, ${crossPosition.col})`);
                    } else {
                        debug(`Posición en cruz (${crossPosition.row}, ${crossPosition.col}) ya ocupada por ficha del mismo jugador`);
                    }
                }
            }
        } else {
            debug(`No se encontraron fichas en posición para entrar a la cruz`);
        }
    } else {
        debug(`El planeta ${basePlanet} no está en la lista de planetas válidos para la cruz`);
    }
    
    // Continuar con el resto de la función para buscar movimientos normales...
    // (código para buscar casillas coincidentes, etc.)
    
    // Al final de la función, mostrar un resumen de todos los movimientos encontrados
    debug(`Total de movimientos posibles: ${gameState.possibleMoves.length}`);
    for (const move of gameState.possibleMoves) {
        if (move.isCrossMove) {
            debug(`Movimiento a cruz: Ficha ${move.pieceId} de (${move.currentRow}, ${move.currentCol}) a (${move.targetRow}, ${move.targetCol}) - Planeta ${move.crossPlanet}`);
        } else if (move.type === 'fromHouse') {
            debug(`Movimiento desde casa a (${move.targetRow}, ${move.targetCol})`);
        } else {
            debug(`Movimiento normal: Ficha ${move.pieceId} de (${move.currentRow}, ${move.currentCol}) a (${move.targetRow}, ${move.targetCol})`);
        }
    }
}

        // Corrección para la función findCrossPlanetPosition
        // Esta función determina la posición correcta en la cruz para un planeta específico

        function findCrossPlanetPosition(basePlanet, playerIdx) {
            const playerZone = playerCrossZones[playerIdx];
            // Planetas en orden: Júpiter, Marte, Venus, Mercurio, Luna, Sol
            const planetSymbols = ["Júpiter", "Marte", "Venus", "Mercurio", "Luna", "Sol"];
            
            // Índice del planeta en la lista
            const planetIndex = planetSymbols.indexOf(basePlanet);
            if (planetIndex === -1) {
                debug(`Planeta no encontrado: ${basePlanet}`);
                return null; // Planeta no encontrado
            }
            
            debug(`Encontrando posición para ${basePlanet} (índice ${planetIndex}) en la cruz de jugador ${playerIdx}`);
            
            // Zonas verticales (Verde y Rosa)
            if (playerZone.type === "vertical") {
                // Para Verde (abajo hacia arriba)
                if (playerIdx === 0) {
                    const row = playerZone.maxRow - planetIndex;
                    const position = { row, col: playerZone.col };
                    debug(`Posición en cruz para ${basePlanet} (Verde): (${position.row}, ${position.col})`);
                    return position;
                }
                // Para Rosa (arriba hacia abajo)
                else if (playerIdx === 2) {
                    const row = playerZone.minRow + planetIndex;
                    const position = { row, col: playerZone.col };
                    debug(`Posición en cruz para ${basePlanet} (Rosa): (${position.row}, ${position.col})`);
                    return position;
                }
            }
            // Zonas horizontales (Azul y Amarillo)
            else {
                // Para Azul (izquierda a derecha)
                if (playerIdx === 1) {
                    const col = playerZone.minCol + planetIndex;
                    const position = { row: playerZone.row, col };
                    debug(`Posición en cruz para ${basePlanet} (Azul): (${position.row}, ${position.col})`);
                    return position;
                }
                // Para Amarillo (derecha a izquierda)
                else if (playerIdx === 3) {
                    const col = playerZone.maxCol - planetIndex;
                    const position = { row: playerZone.row, col };
                    debug(`Posición en cruz para ${basePlanet} (Amarillo): (${position.row}, ${position.col})`);
                    return position;
                }
            }
            
            debug(`No se encontró posición para planeta ${basePlanet} del jugador ${playerIdx}`);
            return null;
        }        

// Verificar si una posición está ocupada por una ficha en una casilla segura
function isOccupiedBySafePiece(row, col) {
    const cell = gameState.board.find(c => c.row === row && c.col === col);
    if (!cell) return false;
    
    // Verificar si hay alguna ficha en esta posición
    const pieces = gameState.pieces.filter(p => p.row === row && p.col === col);
    if (pieces.length === 0) return false;
    
    // Verificar si alguna de estas fichas está en una casilla segura para su propio color
    for (const piece of pieces) {
        // Verificar si la ficha está en las dos últimas filas antes de la cruz
        const isInLastTwoRows = isInLastTwoRowsBeforeCross(row, col, piece.player);
        
        // Verificar si la ficha está en una casilla segura para ese jugador
        const isSafeSpot = !isInLastTwoRows && isPlanetSafeForPlayer(cell.planet, piece.player);
        if (isSafeSpot) {
            return true; // La casilla está ocupada por una ficha en su casilla segura
        }
    }
    
    return false;
}

        // Encontrar movimientos posibles según la tirada del dado
// Función completa findPossibleMoves con todas las funcionalidades
function findPossibleMoves() {
    gameState.possibleMoves = [];
    
    if (!gameState.diceResult) return;
    
    const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
    const currentPlayer = gameState.players[currentPlayerIdx];
    const { planet, boardColor } = gameState.diceResult;
    
    debug(`Buscando movimientos para planeta: ${planet}, color: ${boardColor}`);
    
    // 1. Verificar si hay fichas en posición para entrar a la cruz
    // SOLO cuando la tirada coincide con el planeta específico (ignorando el color)
    const basePlanet = planet.split('_')[0];
    
    // Planetas válidos para la cruz
    const validPlanets = ["Sol", "Luna", "Mercurio", "Venus", "Marte", "Júpiter"];
    
    // Antes de buscar, mostrar información de depuración sobre todas las fichas del jugador actual
    const playerPieces = gameState.pieces.filter(p => p.player === currentPlayerIdx && !p.inCross);
    debug(`El jugador ${currentPlayerIdx} tiene ${playerPieces.length} fichas en el tablero`);
    
    for (const piece of playerPieces) {
        const ready = isPositionReadyForCross(piece.row, piece.col, currentPlayerIdx);
        debug(`Ficha en (${piece.row}, ${piece.col}): ¿Lista para cruz? ${ready}`);
    }
    
    if (validPlanets.includes(basePlanet)) {
        debug(`Planeta base válido para la cruz: ${basePlanet}`);
        
        // Encontrar la posición esperada en la cruz para este planeta
        const expectedCrossPosition = findCrossPlanetPosition(basePlanet, currentPlayerIdx);
        if (expectedCrossPosition) {
            debug(`Posición esperada en cruz para ${basePlanet}: (${expectedCrossPosition.row}, ${expectedCrossPosition.col})`);
        } else {
            debug(`No se encontró posición en cruz para ${basePlanet}`);
        }
        
        // Buscar fichas que estén en posición para entrar a la cruz
        const piecesReadyForCross = playerPieces.filter(p => 
            isPositionReadyForCross(p.row, p.col, currentPlayerIdx)
        );
        
        if (piecesReadyForCross.length > 0) {
            debug(`Encontradas ${piecesReadyForCross.length} fichas en posición para entrar a la cruz`);
            
            // Para cada ficha lista, verificar si puede entrar a la cruz con este planeta
            for (const piece of piecesReadyForCross) {
                const crossPosition = findCrossPlanetPosition(basePlanet, currentPlayerIdx);
                
                if (crossPosition) {
                    debug(`Ficha en (${piece.row}, ${piece.col}) puede entrar a la cruz en (${crossPosition.row}, ${crossPosition.col})`);
                    
                    // Verificar que no hay otra ficha propia en esa posición
                    const isOccupiedBySamePlayer = gameState.pieces.some(p => 
                        p.player === currentPlayerIdx && 
                        p.row === crossPosition.row && 
                        p.col === crossPosition.col);
                    
                    if (!isOccupiedBySamePlayer) {
                        gameState.possibleMoves.push({
                            type: 'normal',
                            pieceId: piece.id,
                            currentRow: piece.row,
                            currentCol: piece.col,
                            targetRow: crossPosition.row,
                            targetCol: crossPosition.col,
                            isCrossMove: true,
                            crossPlanet: basePlanet // Añadir el planeta para verificación posterior
                        });
                        debug(`Añadido movimiento a cruz para planeta ${basePlanet} en (${crossPosition.row}, ${crossPosition.col})`);
                    } else {
                        debug(`Posición en cruz (${crossPosition.row}, ${crossPosition.col}) ya ocupada por ficha del mismo jugador`);
                    }
                }
            }
        } else {
            debug(`No se encontraron fichas en posición para entrar a la cruz`);
        }
    } else {
        debug(`El planeta ${basePlanet} no está en la lista de planetas válidos para la cruz`);
    }
    
    // 2. Buscamos casillas que coincidan exactamente con el planeta y color de la tirada
    const matchingCells = [];
    for (let i = 0; i < gameState.board.length; i++) {
        const cell = gameState.board[i];
        
        // No considerar casillas en la cruz para movimientos normales
        if (cell.isInCross) {
            continue;
        }
        
        // CORRECCIÓN: Mejorar la comparación de colores para incluir correctamente el verde
        const colorMatch = 
            cell.symbolColor === boardColor || 
            (boardColor === 'red' && cell.symbolColor === 'pink') ||
            (boardColor === 'green' && cell.symbolColor === 'green') ||
            (boardColor === 'yellow' && cell.symbolColor === 'yellow') ||
            (boardColor === 'blue' && cell.symbolColor === 'blue');
        if (cell.hasSymbol && cell.planet === planet && colorMatch) {
            // Solo considerar casillas que están en líneas definidas
            if (cell.lineName) {
                matchingCells.push(cell);
                debug(`Celda coincidente encontrada en (${cell.row}, ${cell.col}) - ${cell.lineName}`);
            }
        }
    }
    
    debug(`Encontradas ${matchingCells.length} celdas coincidentes para movimientos normales`);
    
    // 3. Comprobar si puede sacar una ficha de casa
    if (currentPlayer.piecesInHouse > 0) {
        // Solo permitir salir a líneas iniciales específicas para el jugador
        const startLines = playerStartLines[currentPlayerIdx];
        
        for (const cell of matchingCells) {
            if (startLines.includes(cell.lineName)) {
                // Verificar que no hay ficha del mismo jugador en la posición
                const isOccupiedBySamePlayer = gameState.pieces.some(p => 
                    p.player === currentPlayerIdx && 
                    p.row === cell.row && 
                    p.col === cell.col);
                
                // Verificar si la posición está ocupada por una ficha en casilla segura
                const isOccupiedBySafe = isOccupiedBySafePiece(cell.row, cell.col);
                
                if (!isOccupiedBySamePlayer && !isOccupiedBySafe) {
                    gameState.possibleMoves.push({
                        type: 'fromHouse',
                        targetRow: cell.row,
                        targetCol: cell.col,
                        targetLine: cell.lineName
                    });
                    
                    debug(`Movimiento posible desde casa a (${cell.row}, ${cell.col})`);
                } else if (isOccupiedBySafe) {
                    debug(`No se puede salir a (${cell.row}, ${cell.col}) porque hay una ficha en casilla segura`);
                }
            }
        }
    }
    
    // 4. Comprobar movimientos normales para fichas en el tablero
    for (const piece of gameState.pieces) {
        // Solo considerar fichas del jugador actual que no estén en la cruz
        if (piece.player === currentPlayerIdx && !piece.inCross) {
            
            const currentCell = gameState.board.find(c => c.row === piece.row && c.col === piece.col);
            
            debug(`Evaluando posibles movimientos para ficha en (${piece.row}, ${piece.col})`);
            
            // Solo considerar fichas que están en líneas definidas
            if (currentCell && currentCell.lineName) {
                for (const targetCell of matchingCells) {
                    // CORRECCIÓN CLAVE: Verificar líneas conectadas y que no sea línea posterior
                    if (areLinesConnected(currentCell.lineName, targetCell.lineName) && 
                        !isLineInSameDirection(currentCell.lineName, targetCell.lineName)) {
                        
                        // Comprobar que no hay ficha del mismo jugador en la posición
                        const isOccupiedBySamePlayer = gameState.pieces.some(p => 
                            p.player === currentPlayerIdx && 
                            p.row === targetCell.row && 
                            p.col === targetCell.col);
                        
                        // Verificar si la posición está ocupada por una ficha en casilla segura
                        const isOccupiedBySafe = isOccupiedBySafePiece(targetCell.row, targetCell.col);
                        
                        if (!isOccupiedBySamePlayer && !isOccupiedBySafe) {
                            gameState.possibleMoves.push({
                                type: 'normal',
                                pieceId: piece.id,
                                currentRow: piece.row,
                                currentCol: piece.col,
                                targetRow: targetCell.row,
                                targetCol: targetCell.col,
                                currentLine: currentCell.lineName,
                                targetLine: targetCell.lineName,
                                isCrossMove: false
                            });
                            
                            debug(`Movimiento posible de (${piece.row}, ${piece.col}) a (${targetCell.row}, ${targetCell.col}) - Normal`);
                        } else if (isOccupiedBySafe) {
                            debug(`No se puede mover a (${targetCell.row}, ${targetCell.col}) porque hay una ficha en casilla segura`);
                        }
                    } else if (currentCell.lineName === targetCell.lineName) {
                        // Si es la misma línea, permitir el movimiento
                        // Comprobar que no hay ficha del mismo jugador en la posición
                        const isOccupiedBySamePlayer = gameState.pieces.some(p => 
                            p.player === currentPlayerIdx && 
                            p.row === targetCell.row && 
                            p.col === targetCell.col);
                        
                        // Verificar si la posición está ocupada por una ficha en casilla segura
                        const isOccupiedBySafe = isOccupiedBySafePiece(targetCell.row, targetCell.col);
                        
                        if (!isOccupiedBySamePlayer && !isOccupiedBySafe) {
                            gameState.possibleMoves.push({
                                type: 'normal',
                                pieceId: piece.id,
                                currentRow: piece.row,
                                currentCol: piece.col,
                                targetRow: targetCell.row,
                                targetCol: targetCell.col,
                                currentLine: currentCell.lineName,
                                targetLine: targetCell.lineName,
                                isCrossMove: false
                            });
                            
                            debug(`Movimiento posible de (${piece.row}, ${piece.col}) a (${targetCell.row}, ${targetCell.col}) - Misma línea`);
                        } else if (isOccupiedBySafe) {
                            debug(`No se puede mover a (${targetCell.row}, ${targetCell.col}) porque hay una ficha en casilla segura`);
                        }
                    } else {
                        debug(`Movimiento no permitido de ${currentCell.lineName} a ${targetCell.lineName}`);
                    }
                }
            }
        }
    }
    
    // Filtro MEJORADO: Eliminar cualquier movimiento a la cruz que no esté marcado explícitamente como crossMove
    const filteredMoves = [];
    for (const move of gameState.possibleMoves) {
        const targetCell = gameState.board.find(c => c.row === move.targetRow && c.col === move.targetCol);
        
        // Si el destino está en la cruz pero no es un movimiento de cruz válido, excluirlo
        if (targetCell && targetCell.isInCross && (!move.isCrossMove)) {
            debug(`Filtrando movimiento no válido a cruz: (${move.targetRow}, ${move.targetCol})`);
            continue;
        }
        
        // Añadir movimientos válidos
        filteredMoves.push(move);
    }
    
    // Actualizar los movimientos posibles con la lista filtrada
    gameState.possibleMoves = filteredMoves;
    
    debug(`Total movimientos posibles después de filtrado: ${gameState.possibleMoves.length}`);
    for (const move of gameState.possibleMoves) {
        if (move.isCrossMove) {
            debug(`Movimiento a cruz: Ficha ${move.pieceId} de (${move.currentRow}, ${move.currentCol}) a (${move.targetRow}, ${move.targetCol}) - Planeta ${move.crossPlanet}`);
        } else if (move.type === 'fromHouse') {
            debug(`Movimiento desde casa a (${move.targetRow}, ${move.targetCol})`);
        } else {
            debug(`Movimiento normal: Ficha ${move.pieceId} de (${move.currentRow}, ${move.currentCol}) a (${move.targetRow}, ${move.targetCol})`);
        }
    }
}

        // Resaltar los movimientos posibles para una ficha específica
        function highlightPossibleMovesForPiece(piece) {
            clearHighlights();
            
            // Filtrar solo los movimientos para la ficha seleccionada
            const pieceMoves = gameState.possibleMoves.filter(m => m.pieceId === piece.id);
            
            debug(`Resaltando ${pieceMoves.length} movimientos posibles para ficha ${piece.id}`);
            
            // Resaltar cada movimiento posible
            pieceMoves.forEach(move => {
                const targetCell = gameState.board.find(c => c.row === move.targetRow && c.col === move.targetCol);
                
                // Si es un movimiento a la cruz, verificar que sea válido
                if (targetCell && targetCell.isInCross) {
                    // Si no es un movimiento a la cruz, ignorarlo
                    if (!move.isCrossMove) {
                        debug(`Ignorando resaltado de movimiento a cruz no válido: (${move.targetRow}, ${move.targetCol})`);
                        return;
                    }
                    
                    // Verificar que coincida con el planeta
                    if (move.crossPlanet) {
                        const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
                        const expectedPosition = findCrossPlanetPosition(move.crossPlanet, currentPlayerIdx);
                        
                        if (!expectedPosition || 
                            expectedPosition.row !== move.targetRow || 
                            expectedPosition.col !== move.targetCol) {
                            debug(`Ignorando resaltado de movimiento a cruz con planeta incorrecto: (${move.targetRow}, ${move.targetCol})`);
                            return;
                        }
                    }
                }
                
                const cell = document.querySelector(`.cell[data-row="${move.targetRow}"][data-col="${move.targetCol}"]`);
                if (cell) {
                    cell.classList.add('highlight-move');
                }
            });
        }
        
        // Manejar clic en una celda
        function handleCellClick(row, col) {
            // Solo permitir clics si es el turno del jugador humano
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            const currentPlayer = gameState.players[currentPlayerIdx];
            // En handleCellClick, añadir esta verificación antes de las demás
            // Si se ha seleccionado una casa y se hace clic en un destino válido
// En handleCellClick, dentro del bloque donde se maneja la selección de casa
if (gameState.houseSelected) {
    const moveFromHouse = gameState.possibleMoves.find(m => 
        m.type === 'fromHouse' && 
        m.targetRow === row && 
        m.targetCol === col
    );
    
                if (moveFromHouse) {
                    // Colocar nueva ficha
                    placeNewPiece(row, col);
                    
                    // Actualizar controles
                    document.getElementById('roll-dice').disabled = false;
                    document.getElementById('move-piece').disabled = true;
                    document.getElementById('skip-turn').disabled = true;
                    
                    // Limpiar selección de casa
                    const symbolDiv = document.querySelector('.selected-house');
                    if (symbolDiv) {
                        symbolDiv.classList.remove('selected-house');
                    }
                    
                    // Limpiar estado
                    gameState.houseSelected = false;
                    clearHighlights();
                    gameState.selectionMode = false; // Asegurarse de que se desactiva el modo de selección
                    
                    // Verificar si ha ganado
                    checkForWin();
                    
                    // Pasar al siguiente jugador si no ha ganado
                    if (!gameState.gameOver) {
                        nextTurn(); // Asegurarse de que se llama a nextTurn()
                    }
                    return;
                } else {
                    // Si se hace clic en algún lugar que no es un destino válido,
                    // cancelar la selección de casa
                    clearHighlights();
                    gameState.houseSelected = false;
                    logMessage("Selección de casa cancelada. Selecciona otra acción.");
                    return;
                }
            }
                        
            if (currentPlayer.ai) {
                return;
            }
            
            debug(`Clic en celda (${row}, ${col}), modo selección: ${gameState.selectionMode}, ficha seleccionada: ${gameState.selectedPiece !== null}`);
            
            // Si no hay resultado del dado, no hacer nada
            if (!gameState.diceResult) {
                return;
            }
            
            // Buscar información de la celda clicada
            const cell = gameState.board.find(c => c.row === row && c.col === col);
            
            // Verificar si la casilla clicada es parte de la cruz
            if (cell && cell.isInCross && gameState.selectedPiece) {
                // Verificar si la ficha seleccionada está en posición para entrar a la cruz
                const isReadyForCross = isPositionReadyForCross(
                    gameState.selectedPiece.row, 
                    gameState.selectedPiece.col, 
                    currentPlayerIdx
                );
                
                if (!isReadyForCross) {
                    // Si la ficha no está en posición final, mostrar mensaje de error
                    logMessage("No puedes mover a la cruz directamente. Primero debes posicionar tu ficha en la fila/columna adyacente a tu zona de cruz.");
                    return;
                }
                
                // Verificar si el planeta del dado coincide con la posición en la cruz
                const basePlanet = gameState.diceResult.planet.split('_')[0];
                const expectedPosition = findCrossPlanetPosition(basePlanet, currentPlayerIdx);
                
                if (!expectedPosition || expectedPosition.row !== row || expectedPosition.col !== col) {
                    debug(`Movimiento a cruz inválido: planeta ${basePlanet} no coincide con posición (${row}, ${col})`);
                    if (expectedPosition) {
                        logMessage(`Para el planeta ${basePlanet}, la posición correcta en la cruz es (${expectedPosition.row}, ${expectedPosition.col}).`);
                    } else {
                        logMessage(`El planeta ${basePlanet} no tiene una posición válida en la cruz.`);
                    }
                    return;
                }
                
                // Verificar si existe un movimiento explícito a la cruz para esta ficha y posición
                const validCrossMove = gameState.possibleMoves.some(m => 
                    m.pieceId === gameState.selectedPiece.id && 
                    m.targetRow === row && 
                    m.targetCol === col && 
                    m.isCrossMove === true);
                
                if (!validCrossMove) {
                    debug(`No se encontró movimiento explícito a cruz para ficha ${gameState.selectedPiece.id} a (${row}, ${col})`);
                    logMessage("Movimiento a la cruz no válido según las reglas del juego.");
                    return;
                }
                
                debug(`Verificación PASADA: Movimiento válido a cruz con ${basePlanet}`);
            }
            
            // Buscar si hay una ficha en la posición clicada
            const clickedPiece = gameState.pieces.find(p => 
                p.player === currentPlayerIdx && 
                p.row === row && 
                p.col === col && 
                !p.inCross
            );
            
            // NUEVA FUNCIONALIDAD: Si hay una ficha seleccionada y se hace clic en otra ficha propia, cambiar la selección
            if (gameState.selectedPiece && clickedPiece && gameState.selectedPiece.id !== clickedPiece.id) {
                // Quitar resaltado de la ficha anterior
                const oldPieceElement = document.getElementById(gameState.selectedPiece.id);
                if (oldPieceElement) {
                    oldPieceElement.classList.remove('selected-piece');
                }
                
                // Seleccionar la nueva ficha
                gameState.selectedPiece = clickedPiece;
                
                // Verificar si la nueva ficha tiene movimientos válidos
                const hasValidMoves = gameState.possibleMoves.some(m => 
                    m.type === 'normal' && 
                    m.pieceId === clickedPiece.id
                );
                
                if (hasValidMoves) {
                    // Mostrar movimientos posibles para la nueva ficha
                    highlightPossibleMovesForPiece(clickedPiece);
                    logMessage(`Ficha seleccionada en (${row}, ${col}). Haz clic en una casilla resaltada para moverla.`);
                    
                    // Añadir clase visual a la nueva ficha seleccionada
                    const newPieceElement = document.getElementById(clickedPiece.id);
                    if (newPieceElement) {
                        newPieceElement.classList.add('selected-piece');
                    }
                } else {
                    logMessage(`Esta ficha no tiene movimientos válidos. Selecciona otra.`);
                    gameState.selectedPiece = null;
                    clearHighlights();
                    highlightMovablePieces();
                }
                return;
            }
            
            // NUEVA FUNCIONALIDAD: Si la ficha clicada es la misma que ya está seleccionada, deseleccionarla
            if (gameState.selectedPiece && clickedPiece && gameState.selectedPiece.id === clickedPiece.id) {
                // Quitar resaltado y deseleccionar
                const pieceElement = document.getElementById(clickedPiece.id);
                if (pieceElement) {
                    pieceElement.classList.remove('selected-piece');
                }
                
                gameState.selectedPiece = null;
                clearHighlights();
                
                // Mostrar todas las fichas movibles
                gameState.selectionMode = true;
                highlightMovablePieces();
                logMessage(`Ficha deseleccionada. Selecciona una ficha para mover.`);
                return;
            }
            
            // Si estamos en modo selección o se ha clicado en una ficha
            if (gameState.selectionMode || clickedPiece) {
                // Si se ha clicado en una ficha propia
                if (clickedPiece) {
                    // Seleccionar esta ficha y mostrar sus posibles movimientos
                    gameState.selectedPiece = clickedPiece;
                    gameState.selectionMode = false; // Salir del modo selección
                    
                    // Verificar si la ficha tiene movimientos válidos
                    const hasValidMoves = gameState.possibleMoves.some(m => 
                        m.type === 'normal' && 
                        m.pieceId === clickedPiece.id
                    );
                    
                    if (hasValidMoves) {
                        highlightPossibleMovesForPiece(clickedPiece);
                        logMessage(`Ficha seleccionada en (${row}, ${col}). Haz clic en una casilla resaltada para moverla.`);
                        debug(`Ficha ${clickedPiece.id} seleccionada, tiene ${gameState.possibleMoves.filter(m => m.pieceId === clickedPiece.id).length} movimientos posibles`);
                        
                        // Añadir clase visual a la ficha seleccionada
                        const pieceElement = document.getElementById(clickedPiece.id);
                        if (pieceElement) {
                            pieceElement.classList.add('selected-piece');
                        }
                        
                        return;
                    } else {
                        logMessage(`Esta ficha no tiene movimientos válidos.`);
                        gameState.selectedPiece = null;
                        clearHighlights();
                        highlightMovablePieces();
                        gameState.selectionMode = true;
                        return;
                    }
                } else {
                    // No se ha seleccionado una ficha válida, mantener el modo selección
                    logMessage("Selecciona una de tus fichas para mover.");
                    return;
                }
            }
            
            // Si hay una ficha seleccionada, comprobar si el destino es válido
            if (gameState.selectedPiece) {
                const validMove = gameState.possibleMoves.find(m => 
                    m.pieceId === gameState.selectedPiece.id && 
                    m.targetRow === row && 
                    m.targetCol === col
                );
                
                if (validMove) {
                    // Quitar clase visual de la ficha seleccionada
                    const pieceElement = document.getElementById(gameState.selectedPiece.id);
                    if (pieceElement) {
                        pieceElement.classList.remove('selected-piece');
                    }
                    
                    // Realizar el movimiento
                    movePiece(gameState.selectedPiece.id, row, col);
                    
                    // Actualizar controles
                    document.getElementById('roll-dice').disabled = false;
                    document.getElementById('move-piece').disabled = true;
                    document.getElementById('skip-turn').disabled = true;
                    
                    // Limpiar resaltados y selección
                    clearHighlights();
                    gameState.selectedPiece = null;
                    
                    // Verificar si ha ganado
                    checkForWin();
                    
                    // Pasar al siguiente jugador si no ha ganado
                    if (!gameState.gameOver) {
                        nextTurn();
                    }
                    return;
                } else {
                    // Clic en una celda no válida con una ficha seleccionada
                    // Cancelar la selección y mostrar todas las fichas movibles
                    logMessage("Destino no válido. Selecciona otra ficha o un destino válido.");
                    
                    // Quitar clase visual de la ficha seleccionada
                    const pieceElement = document.getElementById(gameState.selectedPiece.id);
                    if (pieceElement) {
                        pieceElement.classList.remove('selected-piece');
                    }
                    
                    gameState.selectedPiece = null;
                    clearHighlights();
                    gameState.selectionMode = true;
                    highlightMovablePieces();
                    return;
                }
            }
            
            // Si no se está en modo selección ni hay ficha seleccionada, comprobar si es un destino válido para salir de casa
            const moveFromHouse = gameState.possibleMoves.find(m => 
                m.type === 'fromHouse' && 
                m.targetRow === row && 
                m.targetCol === col
            );
            
            if (moveFromHouse) {
                placeNewPiece(row, col);
                
                // Actualizar controles
                document.getElementById('roll-dice').disabled = false;
                document.getElementById('move-piece').disabled = true;
                document.getElementById('skip-turn').disabled = true;
                
                // Limpiar resaltados
                clearHighlights();
                gameState.selectedPiece = null;
                
                // Verificar si ha ganado
                checkForWin();
                
                // Pasar al siguiente jugador si no ha ganado
                if (!gameState.gameOver) {
                    nextTurn();
                }
                return;
            }
            
            // Si llegamos aquí, el movimiento no es válido
            logMessage("Movimiento no válido. Selecciona una ficha o una casilla resaltada.");
        }
        
        // Función para manejar clics en los símbolos de las casas
        function handleHouseSymbolClick(playerIndex) {
            // Solo permitir seleccionar casa del jugador actual
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            if (playerIndex !== currentPlayerIdx) {
                logMessage("Solo puedes seleccionar fichas de tu propia casa.");
                return;
            }
            
            // Verificar si es el turno del jugador humano
            const currentPlayer = gameState.players[currentPlayerIdx];
            if (currentPlayer.ai) {
                return;
            }
            
            // Verificar si se ha tirado el dado
            if (!gameState.diceResult) {
                logMessage("Primero debes tirar el dado.");
                return;
            }
            
            // Verificar si hay fichas en casa
            if (currentPlayer.piecesInHouse <= 0) {
                logMessage("No tienes fichas en casa.");
                return;
            }
            
            // Verificar si hay movimientos posibles desde casa
            const fromHouseMoves = gameState.possibleMoves.filter(m => m.type === 'fromHouse');
            if (fromHouseMoves.length === 0) {
                logMessage("No hay movimientos posibles desde casa con el dado actual.");
                return;
            }
            
            // Limpiar cualquier selección previa
            clearHighlights();
            gameState.selectedPiece = null;
            
            // Resaltar los destinos posibles
            for (const move of fromHouseMoves) {
                const cell = document.querySelector(`.cell[data-row="${move.targetRow}"][data-col="${move.targetCol}"]`);
                if (cell) {
                    cell.classList.add('highlight-move');
                }
            }
            
            // Indicar visualmente que se ha seleccionado la casa
            const symbolDiv = document.querySelector(`.house-symbol[data-house="${playerIndex}"]`);
            if (symbolDiv) {
                symbolDiv.classList.add('selected-house');
            }
            
            // Activar modo de casa seleccionada
            gameState.houseSelected = true;
            
            logMessage("Casa seleccionada. Haz clic en una casilla resaltada para colocar tu ficha.");
        }

        // Colocar una nueva ficha desde la casa
        function placeNewPiece(row, col) {
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            const currentPlayer = gameState.players[currentPlayerIdx];
            
            debug(`Colocando nueva ficha en (${row}, ${col}) para jugador ${currentPlayerIdx}`);
            
            // Crear nueva ficha en el DOM
            const boardDiv = document.getElementById('board');
            const cellDiv = boardDiv.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            const pieceDiv = document.createElement('div');
            pieceDiv.className = `piece ${currentPlayer.color}`;
            
            const pieceId = `piece-${currentPlayer.color}-${Date.now()}`;
            pieceDiv.id = pieceId;
            
            cellDiv.appendChild(pieceDiv);
            
            // Verificar si la casilla destino es parte de la cruz
            const cell = gameState.board.find(c => c.row === row && c.col === col);
            const isInCross = cell && cell.isInCross;
            
            // Actualizar estado del juego
            const newPiece = {
                id: pieceId,
                player: currentPlayerIdx,
                row,
                col,
                inCross: isInCross
            };
            
            gameState.pieces.push(newPiece);
            
            // Actualizar estado del jugador
            currentPlayer.piecesInHouse--;
            
            if (isInCross) {
                currentPlayer.piecesInCross++;
            }
            
            // Actualizar las casas en el DOM
            updateHousesDisplay();
            
            // Comprobar si hay alguna ficha para comer
            checkForCapturing(row, col);
            
            // Log
            logMessage(`${currentPlayer.name} ha sacado una ficha de casa a la posición (${row}, ${col}).`);
        }
        
        // Mover una ficha
        function movePiece(pieceId, targetRow, targetCol) {
            // Encontrar la ficha
            const pieceIndex = gameState.pieces.findIndex(p => p.id === pieceId);
            if (pieceIndex === -1) {
                debug(`Error: No se encontró la ficha con ID ${pieceId}`);
                return;
            }
            
            const piece = gameState.pieces[pieceIndex];
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            const currentPlayer = gameState.players[currentPlayerIdx];
            
            debug(`Moviendo ficha ${pieceId} de (${piece.row}, ${piece.col}) a (${targetRow}, ${targetCol})`);
            
            // Comprobar si es un movimiento a la cruz desde la posición final
            const isMoveToCross = isPositionReadyForCross(piece.row, piece.col, currentPlayerIdx) &&
                                 gameState.board.find(c => c.row === targetRow && c.col === targetCol)?.isInCross;
            
            // Actualizar posición en el DOM
            const pieceDiv = document.getElementById(pieceId);
            if (!pieceDiv) {
                debug(`Error: No se encontró el elemento DOM para la ficha ${pieceId}`);
                return;
            }
            
            const oldCellDiv = document.querySelector(`[data-row="${piece.row}"][data-col="${piece.col}"]`);
            const newCellDiv = document.querySelector(`[data-row="${targetRow}"][data-col="${targetCol}"]`);
            
            if (!oldCellDiv || !newCellDiv) {
                debug(`Error: No se encontraron las celdas para el movimiento`);
                return;
            }
            
            oldCellDiv.removeChild(pieceDiv);
            newCellDiv.appendChild(pieceDiv);
            
            // Verificar si la casilla destino es parte de la cruz
            const targetCell = gameState.board.find(c => c.row === targetRow && c.col === targetCol);
            
            // Actualizar estado del juego
            piece.row = targetRow;
            piece.col = targetCol;
            
            // Si el movimiento es a la cruz, marcar la ficha como inCross
            if (isMoveToCross) {
                piece.inCross = true;
                currentPlayer.piecesInCross++;
                debug(`Ficha ha entrado en la cruz del jugador ${currentPlayerIdx} (movimiento especial)`);
                logMessage(`${currentPlayer.name} ha colocado una ficha en su cruz (${targetRow}, ${targetCol}).`);
            } 
            // Verificar si la ficha ha llegado a la cruz por un movimiento normal
            else if (targetCell && targetCell.isInCross && !piece.inCross) {
                // Solo si es la cruz del jugador actual
                if (targetCell.crossColor === currentPlayer.crossZone) {
                    piece.inCross = true;
                    currentPlayer.piecesInCross++;
                    debug(`Ficha ha entrado en la cruz del jugador ${currentPlayerIdx}`);
                    logMessage(`${currentPlayer.name} ha colocado una ficha en su cruz (${targetRow}, ${targetCol}).`);
                }
            }
            
            // Comprobar si hay alguna ficha para comer (solo si no es un movimiento a la cruz)
            if (!isMoveToCross) {
                checkForCapturing(targetRow, targetCol);
            }
            
            // Log si no es movimiento a cruz (ya se hizo log arriba para ese caso)
            if (!isMoveToCross && (!targetCell || !targetCell.isInCross)) {
                logMessage(`${currentPlayer.name} ha movido una ficha a la posición (${targetRow}, ${targetCol}).`);
            }
        }
        
        // Comprobar si hay fichas para comer
// Comprobar si hay fichas para comer
function checkForCapturing(row, col) {
    // Si la ficha está en la cruz, no puede comer ni ser comida
    const cell = gameState.board.find(c => c.row === row && c.col === col);
    if (cell && cell.isInCross) {
        return;
    }
    
    const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
    debug(`Comprobando si hay fichas para comer en (${row}, ${col})`);
    
    // Obtener todas las fichas en esta posición que no son del jugador actual
    const pieces = gameState.pieces.filter(p => 
        p.row === row && p.col === col && 
        p.player !== currentPlayerIdx);
    
    if (pieces.length > 0) {
        debug(`Se encontraron ${pieces.length} fichas para evaluar en (${row}, ${col})`);
        
        // Para cada ficha, verificar si está en una casilla segura para su propio color
        const piecesToRemove = [];
        
        for (const piece of pieces) {
            // Verificar si la ficha está en las dos últimas filas antes de la cruz
            const isInLastTwoRows = isInLastTwoRowsBeforeCross(row, col, piece.player);
            
            // Verificar si la ficha está en una casilla segura para su color
            const isSafeSpot = !isInLastTwoRows && isPlanetSafeForPlayer(cell.planet, piece.player);
            
            if (isSafeSpot) {
                debug(`Ficha de jugador ${piece.player} está en casilla segura (${cell.planet}), no puede ser comida`);
                // Si hay al menos una ficha en casilla segura, cancelamos toda la operación
                // No podemos mover a esta casilla
                return;
            } else {
                // La ficha no está en una casilla segura, se puede comer
                piecesToRemove.push(piece);
            }
        }
        
        // Procesar las fichas que se pueden comer
        for (const piece of piecesToRemove) {
            // Eliminar la ficha del DOM
            const pieceDiv = document.getElementById(piece.id);
            if (pieceDiv) {
                const cellDiv = pieceDiv.parentNode;
                cellDiv.removeChild(pieceDiv);
            }
            
            // Actualizar estado del jugador
            const capturedPlayer = gameState.players[piece.player];
            capturedPlayer.piecesInHouse++;
            
            // Si la ficha estaba en la cruz, actualizar contador
            if (piece.inCross) {
                capturedPlayer.piecesInCross--;
            }
            
            // Log
            logMessage(`${gameState.players[currentPlayerIdx].name} ha comido una ficha de ${capturedPlayer.name}.`);
        }
        
        // Eliminar las fichas comidas del estado del juego
        gameState.pieces = gameState.pieces.filter(p => 
            !(p.row === row && p.col === col && p.player !== currentPlayerIdx));
        
        // Actualizar las casas en el DOM
        updateHousesDisplay();
    }
}
        
        // Verificar si un jugador ha ganado
        function checkForWin() {
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            const currentPlayer = gameState.players[currentPlayerIdx];
            
            debug(`Verificando si el jugador ${currentPlayerIdx} ha ganado (${currentPlayer.piecesInCross}/6)`);
            
            // Verificar que tiene 6 fichas en la cruz
            if (currentPlayer.piecesInCross >= 6) {
                gameState.gameOver = true;
                logMessage(`¡${currentPlayer.name} ha ganado la partida!`);
                
                // Desactivar controles
                document.getElementById('roll-dice').disabled = true;
                document.getElementById('move-piece').disabled = true;
                document.getElementById('skip-turn').disabled = true;
                
                // Mostrar mensaje de victoria
                alert(`¡${currentPlayer.name} ha ganado la partida!`);
            }
        }
        
        // Actualizar visualización de las casas
        function updateHousesDisplay() {
            const playerInfoDivs = document.querySelectorAll('.player-info');
            
            for (let i = 0; i < gameState.activePlayerIndices.length; i++) {
                const playerIdx = gameState.activePlayerIndices[i];
                const player = gameState.players[playerIdx];
                const houseDiv = playerInfoDivs[i].querySelector('.houses');
                
                // Actualizar piezas en casa
                houseDiv.innerHTML = '';
                for (let j = 0; j < player.piecesInHouse; j++) {
                    const housePiece = document.createElement('div');
                    housePiece.className = `house-piece ${player.color}`;
                    houseDiv.appendChild(housePiece);
                }
            }
        }
        
// Verificar si un planeta es seguro para un jugador específico
function isPlanetSafeForPlayer(planet, playerIdx) {
    // Si no hay safe spots definidos para el jugador, no hay casillas seguras
    if (!safeSpots[playerIdx]) return false;
    
    // Comprobar si el planeta coincide con alguna casilla segura del jugador
    return safeSpots[playerIdx].some(spot => spot.planet === planet);
}

// Verificar si una posición está en las dos últimas filas antes de la cruz
function isInLastTwoRowsBeforeCross(row, col, playerIdx) {
    // Verde (jugador 0): filas 11 y 12 cerca de la cruz vertical
    if (playerIdx === 0) {
        return (col === 6 || col === 8) && (row === 11 || row === 12);
    }
    // Azul (jugador 1): columnas 11 y 12 cerca de la cruz horizontal
    else if (playerIdx === 1) {
        return (row === 6 || row === 8) && (col === 11 || col === 12);
    }
    // Rosa (jugador 2): filas 2 y 3 cerca de la cruz vertical
    else if (playerIdx === 2) {
        return (col === 6 || col === 8) && (row === 2 || row === 3);
    }
    // Amarillo (jugador 3): columnas 2 y 3 cerca de la cruz horizontal 
    else if (playerIdx === 3) {
        return (row === 6 || row === 8) && (col === 2 || col === 3);
    }
    return false;
}

        // Pasar al siguiente jugador
        function nextTurn() {
            debug(`Pasando al siguiente jugador desde ${gameState.currentPlayer}`);
            
            // Reiniciar estado del dado
            gameState.diceResult = null;
            gameState.possibleMoves = [];
            
            // Limpiar información del elemento
            document.getElementById('element-info').textContent = '';
            document.getElementById('dice-result').textContent = '';
            document.getElementById('dice-result').className = 'dice-result';
            
            // Actualizar indicador visual del jugador activo
            const playerInfoDivs = document.querySelectorAll('.player-info');
            playerInfoDivs[gameState.currentPlayer].classList.remove('active');
            
            // Encontrar el siguiente jugador en el orden circular
            gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.activePlayerIndices.length;
            
            playerInfoDivs[gameState.currentPlayer].classList.add('active');
            
            // Obtener el índice real del jugador actual
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            
            // Log
            logMessage(`Turno de ${gameState.players[currentPlayerIdx].name}.`);
            
            // Limpiar selecciones previas
            clearHighlights();
            gameState.selectionMode = false;
            gameState.selectedPiece = null;
            
            // Habilitar botón de tirar dado
            document.getElementById('roll-dice').disabled = false;
            document.getElementById('move-piece').disabled = true;
            document.getElementById('skip-turn').disabled = true;
            
            // Si es IA, jugar automáticamente después de un breve retraso
            if (gameState.players[currentPlayerIdx].ai && !gameState.gameOver) {
                setTimeout(() => {
                    document.getElementById('roll-dice').click();
                }, 1000);
            }
        }
        
        // Jugar turno de IA
        function playAITurn() {
            // Si no hay movimientos posibles, pasar al siguiente jugador
            if (gameState.possibleMoves.length === 0) {
                setTimeout(() => {
                    nextTurn();
                }, 1000);
                return;
            }
            
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            debug(`IA jugando turno (jugador ${currentPlayerIdx})`);
            
            // Estrategia de la IA: priorizar movimientos a la cruz, luego comer, luego mover
            let selectedMove = null;
            
            // 1. Priorizar mover a la cruz
            const crossMoves = gameState.possibleMoves.filter(move => 
                move.isCrossMove === true && move.crossPlanet);
            
            if (crossMoves.length > 0) {
                // Verificar que cada movimiento a la cruz sea válido
                const validCrossMoves = crossMoves.filter(move => {
                    const expectedPosition = findCrossPlanetPosition(
                        move.crossPlanet, 
                        currentPlayerIdx
                    );
                    
                    return expectedPosition && 
                           expectedPosition.row === move.targetRow && 
                           expectedPosition.col === move.targetCol;
                });
                
                if (validCrossMoves.length > 0) {
                    selectedMove = validCrossMoves[Math.floor(Math.random() * validCrossMoves.length)];
                    debug(`IA seleccionó movimiento a la cruz con planeta ${selectedMove.crossPlanet}`);
                }
            }
            // 2. Priorizar comer fichas enemigas
            else {
                const capturingMoves = [];
                
                for (const move of gameState.possibleMoves) {
                    // Para movimientos a la cruz, verificar que coincidan con el planeta
                    if (move.isCrossMove) {
                        const expectedPosition = findCrossPlanetPosition(
                            move.crossPlanet, 
                            currentPlayerIdx
                        );
                        
                        if (!expectedPosition || 
                            expectedPosition.row !== move.targetRow || 
                            expectedPosition.col !== move.targetCol) {
                            continue; // Saltar este movimiento a la cruz si no coincide
                        }
                    }
                    
                    const enemyPieceExists = gameState.pieces.some(p => 
                        p.row === move.targetRow && 
                        p.col === move.targetCol && 
                        p.player !== currentPlayerIdx);
                    
                    if (enemyPieceExists) {
                        capturingMoves.push(move);
                    }
                }
                
                if (capturingMoves.length > 0) {
                    selectedMove = capturingMoves[Math.floor(Math.random() * capturingMoves.length)];
                    debug(`IA seleccionó movimiento para comer`);
                }
                // 3. Mover aleatoriamente
                else {
                    // Filtrar movimientos a la cruz que no coincidan con el planeta
                    const validMoves = gameState.possibleMoves.filter(move => {
                        // Si es un movimiento a la cruz, verificar el planeta
                        if (move.isCrossMove) {
                            const expectedPosition = findCrossPlanetPosition(
                                move.crossPlanet, 
                                currentPlayerIdx
                            );
                            
                            return expectedPosition && 
                                   expectedPosition.row === move.targetRow && 
                                   expectedPosition.col === move.targetCol;
                        }
                        
                        // No es movimiento a la cruz, es válido
                        return true;
                    });
                    
                    if (validMoves.length > 0) {
                        selectedMove = validMoves[Math.floor(Math.random() * validMoves.length)];
                        debug(`IA seleccionó movimiento aleatorio`);
                    }
                }
            }
            
            // Ejecutar el movimiento seleccionado
            if (selectedMove) {
                debug(`IA ejecutando movimiento: ${JSON.stringify(selectedMove)}`);
                
                if (selectedMove.type === 'fromHouse') {
                    placeNewPiece(selectedMove.targetRow, selectedMove.targetCol);
                } else {
                    movePiece(selectedMove.pieceId, selectedMove.targetRow, selectedMove.targetCol);
                }
                
                // Actualizar controles
                document.getElementById('roll-dice').disabled = false;
                document.getElementById('move-piece').disabled = true;
                document.getElementById('skip-turn').disabled = true;
                
                // Limpiar resaltados
                clearHighlights();
                
                // Verificar si ha ganado
                checkForWin();
                
                // Pasar al siguiente jugador si no ha ganado
                if (!gameState.gameOver) {
                    setTimeout(() => {
                        nextTurn();
                    }, 1000);
                }
            } else {
                // Pasar turno si no hay movimiento seleccionado
                debug(`IA no encontró movimiento válido`);
                setTimeout(() => {
                    nextTurn();
                }, 1000);
            }
        }
        
        // Función para resaltar fichas que pueden moverse
        function highlightMovablePieces() {
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            debug("Resaltando fichas movibles para el jugador " + currentPlayerIdx);
            clearHighlights();
            
            // Encontrar todas las fichas del jugador actual con movimientos posibles
            const playerPieces = gameState.pieces.filter(p => 
                p.player === currentPlayerIdx && !p.inCross);
            
            debug(`Encontradas ${playerPieces.length} fichas del jugador en el tablero`);
            
            // Para cada ficha, verificar si tiene al menos un movimiento posible
            let hasMovablePieces = false;
            
            for (const piece of playerPieces) {
                const hasMoves = gameState.possibleMoves.some(m => 
                    m.type === 'normal' && m.pieceId === piece.id);
                
                debug(`Ficha en (${piece.row}, ${piece.col}) tiene movimientos: ${hasMoves}`);
                
                if (hasMoves) {
                    // Resaltar la celda donde está la ficha
                    const cell = document.querySelector(`.cell[data-row="${piece.row}"][data-col="${piece.col}"]`);
                    if (cell) {
                        cell.classList.add('highlight-move');
                        hasMovablePieces = true;
                    }
                }
            }
            
            // Si no hay fichas movibles, mostrar un mensaje
            if (!hasMovablePieces) {
                logMessage("No hay fichas que se puedan mover. Intenta sacar una ficha de casa o pasa turno.");
                
                // Resaltar posibles movimientos desde casa si existen
                const houseMovesExist = gameState.possibleMoves.some(m => m.type === 'fromHouse');
                if (houseMovesExist) {
                    for (const move of gameState.possibleMoves) {
                        if (move.type === 'fromHouse') {
                            const cell = document.querySelector(`.cell[data-row="${move.targetRow}"][data-col="${move.targetCol}"]`);
                            if (cell) {
                                cell.classList.add('highlight-move');
                            }
                        }
                    }
                }
            }
            
            return hasMovablePieces;
        }
        
        // Registrar mensaje en el log
        function logMessage(message) {
            const logDiv = document.getElementById('message-log');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.textContent = message;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        // Mostrar información sobre las líneas del tablero
        function showLineInfo() {
            logMessage('-----LÍNEAS DEL TABLERO-----');
            logMessage('Rojo_Humedo (Rosa): Columna 6, Filas 0 a 5');
            logMessage('Rojo_Seco (Rosa): Fila 6, columnas 0 a 5');
            logMessage('Amarillo_Humedo (Amarillo): Fila 8, Columnas 0 a 5');
            logMessage('Amarillo_Seco (Amarillo): Columna 6, Filas de 9 a 14');
            logMessage('Verde_Humedo (Verde): Columna 8, filas de 9 a 14');
            logMessage('Verde_Seco (Verde): Fila 8, Columnas de 9 a 14');
            logMessage('Azul_Humedo (Azul): Fila 6, Columnas de 9 a 14');
            logMessage('Azul_Seco (Azul): Columna 8, Filas de 0 a 5');
            logMessage('------------------------');
            
            // Mostrar líneas para salir de casa
            logMessage('-----LÍNEAS INICIALES POR JUGADOR-----');
            logMessage('Jugador 1 (Verde): ' + playerStartLines[0].join(', '));
            logMessage('Jugador 2 (Azul): ' + playerStartLines[1].join(', '));
            logMessage('Jugador 3 (Rosa): ' + playerStartLines[2].join(', '));
            logMessage('Jugador 4 (Amarillo): ' + playerStartLines[3].join(', '));
            logMessage('------------------------');
            
            // Mostrar reglas de adyacencia
            logMessage('-----LÍNEAS ADYACENTES-----');
            for (const [line, adjacents] of Object.entries(adjacentLines)) {
                logMessage(`${line} conecta con: ${adjacents.join(', ')}`);
            }
            
            // Mostrar restricciones
            logMessage('-----RESTRICCIONES DE MOVIMIENTO-----');
            logMessage('- Si una ficha está en Línea Húmeda de su casa, no puede moverse a Línea Seca de la casa anterior.');
            logMessage('------------------------');
            
            // Mostrar información sobre casillas seguras
            if (gameState.gameMode === 4) {
                logMessage('-----CASILLAS SEGURAS (Modo 4 jugadores)-----');
                for (let i = 0; i < 4; i++) {
                    const colorName = playerInfo[i].colorName;
                    logMessage(`Jugador ${i+1} (${colorName}): ${safeSpots[i].map(spot => spot.planet).join(', ')}`);
                }
                logMessage('IMPORTANTE: En las dos últimas filas antes de la cruz, NO hay casillas seguras');
                logMessage('------------------------');
            }

        }
        
        // FUNCIONES PARA CONFIGURACIÓN DEL JUEGO
        
        // Generar el selector de jugadores basado en el modo seleccionado
        function generatePlayerSelector() {
            const playerSelector = document.getElementById('player-selector');
            playerSelector.innerHTML = '';
            
            // Obtener jugadores para el modo seleccionado
            const players = gameState.activePlayerIndices || gameConfigs[gameState.gameMode];
            debug(`Generando selector para ${players.length} jugadores en modo ${gameState.gameMode}`);
            debug(`Jugadores activos: ${players.join(',')}`);
            
            // Configurar el ancho de las tarjetas según el número de jugadores
            const cardWidth = players.length === 2 ? '48%' : '48%';
            
            for (const playerIdx of players) {
                const player = playerInfo[playerIdx];
                
                const playerCard = document.createElement('div');
                playerCard.className = `player-card ${player.color} ${gameState.humanPlayers.includes(playerIdx) ? 'selected' : ''}`;
                playerCard.dataset.player = playerIdx;
                playerCard.style.width = cardWidth;
                
                playerCard.innerHTML = `
                    <h3>${player.name} (${player.colorName})</h3>
                    <div class="player-toggle">
                        <input type="checkbox" id="player-human-${playerIdx}" 
                               ${gameState.humanPlayers.includes(playerIdx) ? 'checked' : ''}>
                        <label for="player-human-${playerIdx}">Jugador Humano</label>
                    </div>
                `;
                
                // Añadir evento de clic para seleccionar/deseleccionar
                playerCard.addEventListener('click', () => {
                    const checkbox = playerCard.querySelector(`#player-human-${playerIdx}`);
                    checkbox.checked = !checkbox.checked;
                    
                    if (checkbox.checked) {
                        playerCard.classList.add('selected');
                        if (!gameState.humanPlayers.includes(playerIdx)) {
                            gameState.humanPlayers.push(playerIdx);
                        }
                    } else {
                        playerCard.classList.remove('selected');
                        gameState.humanPlayers = gameState.humanPlayers.filter(p => p !== playerIdx);
                    }
                    debug(`Jugador ${playerIdx} seleccionado como humano: ${checkbox.checked}`);
                    debug(`Jugadores humanos actuales: ${gameState.humanPlayers.join(', ')}`);
                });
                
                playerSelector.appendChild(playerCard);
            }
        }
        
        // Inicializar estado del juego según la configuración
        function initializeGameState() {
            // Reiniciar estado
            gameState.currentPlayer = 0;
            gameState.players = [];
            gameState.pieces = [];
            gameState.diceResult = null;
            gameState.selectedPiece = null;
            gameState.possibleMoves = [];
            gameState.selectionMode = false;
            gameState.gameOver = false;
            
            // Usar los jugadores activos ya configurados (no sobreescribir)
            debug(`Modo de juego ${gameState.gameMode}`);
            debug(`Índices de jugadores activos: ${gameState.activePlayerIndices.join(',')}`);
            debug(`Jugadores humanos: ${gameState.humanPlayers.join(',')}`);
            
            // Inicializar jugadores
            for (let i = 0; i < 4; i++) {
                const info = playerInfo[i];
                gameState.players[i] = {
                    name: info.name,
                    color: info.color,
                    colorName: info.colorName,
                    piecesInHouse: 6,
                    piecesInCross: 0,
                    ai: !gameState.humanPlayers.includes(i),
                    crossZone: info.crossZone,
                    bgColor: `rgba(${hexToRgb(info.colorHex)}, 0.2)`
                };
            }
            
            debug(`Juego inicializado con ${gameState.activePlayerIndices.length} jugadores, ${gameState.humanPlayers.length} humanos`);
        }
        
        // Convertir color hexadecimal a RGB
        function hexToRgb(hex) {
            // Remover el # si existe
            hex = hex.replace('#', '');
            
            // Convertir a RGB
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            
            return `${r}, ${g}, ${b}`;
        }
        
        // Iniciar el juego una vez configurado
        // Iniciar el juego una vez configurado
        function startGame() {
            // Ocultar el diálogo de configuración
            document.getElementById('config-dialog').style.display = 'none';
            
            // Inicializar el estado del juego
            initializeGameState();
            
            // Inicializar el tablero
            initializeBoard();
            
            // Inicializar la interfaz de jugadores
            initializePlayerInfo();
            
            // Mostrar mensaje de inicio
            const messageLog = document.getElementById('message-log');
            messageLog.innerHTML = '';
            logMessage(`¡El juego ha comenzado! Modo: ${gameState.gameMode} jugadores.`);
            logMessage(`Turno de ${gameState.players[gameState.activePlayerIndices[0]].name}.`);
            
            // Mostrar reglas
            logMessage('-----REGLAS DEL JUEGO-----');
            logMessage('1. Tira el dado para obtener un planeta y un elemento (color).');
            logMessage('2. Solo puedes mover a casillas con ese planeta y ese color específico.');
            logMessage('3. Los movimientos pueden ser en la misma línea o líneas adyacentes según las reglas.');
            logMessage('4. Puedes seleccionar la ficha que quieres mover haciendo clic en ella.');
            logMessage('5. Si una ficha está en la Línea Húmeda de su casa, no puede moverse a la Línea Seca de la casa anterior.');
            logMessage('6. Al salir de casa, solo puedes ir a las líneas de tu propio color.');
            logMessage('7. Para llegar a la cruz, primero debes posicionar tu ficha en la fila/columna adyacente a tu zona.');
            logMessage('8. Desde esta posición, solo podrás mover a la cruz cuando el dado muestre el planeta específico que');
            logMessage('   corresponde a cada posición de tu zona, SIN importar el color del planeta.');
            logMessage('9. Las fichas en la cruz no pueden moverse ni ser comidas.');
            
            // Reglas específicas para modo 4 jugadores
            if (gameState.gameMode === 4) {
            logMessage('10. Cada jugador tiene 2 casillas seguras donde sus fichas no pueden ser comidas:');
            logMessage('    - Verde: Mercurio verde y Venus verde');
            logMessage('    - Azul: Marte azul y Júpiter azul');
            logMessage('    - Rosa: Júpiter rosa y Marte rosa');
            logMessage('    - Amarillo: Venus amarillo y Mercurio amarillo');
            logMessage('11. Si una ficha está en una casilla segura, ninguna otra ficha puede ocupar esa casilla.');
            logMessage('12. En las dos últimas filas antes de la cruz, NO hay casillas seguras para ningún jugador.');
            logMessage('13. Para ganar, lleva 6 fichas a tu zona de la cruz.');
            logMessage('14. El orden de juego depende de los jugadores activos.');
            } else {
                logMessage('10. Para ganar, lleva 6 fichas a tu zona de la cruz.');
                logMessage('11. El orden de juego depende de los jugadores activos.');
            }
            logMessage('------------------------');
            
            // Mostrar información de las líneas
            showLineInfo();
            
            // Si el primer jugador es IA, hacer su movimiento
            if (gameState.players[gameState.activePlayerIndices[0]].ai) {
                setTimeout(() => {
                    document.getElementById('roll-dice').click();
                }, 1000);
            }
        }
        
        // EVENTOS DE LA CONFIGURACIÓN
        
        // Evento al cambiar el modo de juego
        document.getElementById('mode-2').addEventListener('click', function() {
            debug("Cambiando a modo 2 jugadores");
            document.getElementById('mode-4').classList.remove('selected');
            this.classList.add('selected');
            gameState.gameMode = 2;
            gameState.activePlayerIndices = gameConfigs[2];
            
            // Filtrar jugadores humanos para que solo queden los que están en el nuevo modo
            gameState.humanPlayers = gameState.humanPlayers.filter(p => gameConfigs[2].includes(p));
            if (gameState.humanPlayers.length === 0) {
                gameState.humanPlayers = [0]; // Por defecto, el jugador 1 es humano
            }
            
            debug(`Modo 2 jugadores: índices activos = ${gameState.activePlayerIndices.join(',')}`);
            debug(`Jugadores humanos = ${gameState.humanPlayers.join(',')}`);
            
            generatePlayerSelector();
        });
        
        document.getElementById('mode-4').addEventListener('click', function() {
            debug("Cambiando a modo 4 jugadores");
            document.getElementById('mode-2').classList.remove('selected');
            this.classList.add('selected');
            gameState.gameMode = 4;
            gameState.activePlayerIndices = gameConfigs[4];
            
            // Asegurarse de que haya al menos un jugador humano seleccionado
            if (gameState.humanPlayers.length === 0) {
                gameState.humanPlayers = [0]; // Por defecto, el jugador 1 es humano
            }
            
            debug(`Modo 4 jugadores: índices activos = ${gameState.activePlayerIndices.join(',')}`);
            debug(`Jugadores humanos = ${gameState.humanPlayers.join(',')}`);
            
            generatePlayerSelector();
        });
        
        // Evento para comenzar el juego
        document.getElementById('start-game').addEventListener('click', function() {
            // Validar que al menos un jugador es humano
            if (gameState.humanPlayers.length === 0) {
                alert('Debes seleccionar al menos un jugador humano.');
                return;
            }
            startGame();
        });
        
        // Eventos para controles del juego
        document.getElementById('roll-dice').addEventListener('click', rollDice);
        document.getElementById('move-piece').addEventListener('click', () => {
            // Limpiar cualquier selección previa, incluyendo selección de casa
            clearHighlights();
            gameState.selectedPiece = null;
            gameState.houseSelected = false;
            gameState.selectionMode = true;
            
            // Mostrar mensaje de ayuda
            logMessage("Selecciona una de tus fichas para mover.");
            
            // Destacar fichas movibles
            highlightMovablePieces();
        });
        
        document.getElementById('skip-turn').addEventListener('click', () => {
            if (!gameState.diceResult) return;
            
            // Limpiar estado de selección
            clearHighlights();
            gameState.selectionMode = false;
            gameState.selectedPiece = null;
            
            const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
            logMessage(`${gameState.players[currentPlayerIdx].name} ha pasado su turno.`);
            nextTurn();
        });
        
        // Inicializar el panel de configuración
        generatePlayerSelector();

// Función corregida: solo restringe el movimiento específico de línea húmeda de casa propia a línea seca de casa anterior
function isLineInSameDirection(line1, line2) {
    if (!line1 || !line2) return false;
    
    // Extraer información de las líneas
    const getLineInfo = (line) => {
        const color = line.includes("Rojo") ? "Rojo" : 
                     line.includes("Amarillo") ? "Amarillo" : 
                     line.includes("Verde") ? "Verde" : 
                     line.includes("Azul") ? "Azul" : "";
                     
        const type = line.includes("Humedo") ? "Humedo" : "Seco";
        
        return { color, type };
    };
    
    const line1Info = getLineInfo(line1);
    const line2Info = getLineInfo(line2);
    
    // Obtener el jugador actual
    const currentPlayerIdx = gameState.activePlayerIndices[gameState.currentPlayer];
    
    // Mapeo de jugadores a sus colores y casas adyacentes
    const playerColors = {
        0: "Verde",     // Jugador Verde
        1: "Azul",      // Jugador Azul
        2: "Rojo",      // Jugador Rosa
        3: "Amarillo"   // Jugador Amarillo
    };
    
    // Mapeo de casas anteriores para cada jugador
    const previousColors = {
        "Verde": "Amarillo",
        "Azul": "Verde",
        "Rojo": "Azul",
        "Amarillo": "Rojo"
    };
    
    // Obtener el color del jugador actual
    const playerColor = playerColors[currentPlayerIdx];
    // Obtener el color de la casa anterior
    const previousColor = previousColors[playerColor];
    
    // SÓLO restringir cuando:
    // 1. Se está en línea húmeda de la casa propia
    // 2. Se intenta mover a línea seca de la casa anterior
    if (line1Info.color === playerColor && line1Info.type === "Humedo" && 
        line2Info.color === previousColor && line2Info.type === "Seco") {
        debug(`RESTRICCIÓN: Jugador ${currentPlayerIdx} (${playerColor}) no puede mover de su línea Húmeda a línea Seca de ${previousColor}`);
        return true; // Movimiento prohibido
    }
    
    // Cualquier otro movimiento está permitido
    return false;
}
    </script>
</body>
</html>